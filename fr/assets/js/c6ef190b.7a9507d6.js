"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6928],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2580:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return u},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return d}});var a=n(3117),r=(n(7294),n(3905));const i={sidebar_position:2},o="Developing a Smart Contract",s={unversionedId:"develop-smart-contract/develop",id:"develop-smart-contract/develop",title:"Developing a Smart Contract",description:"In this section, we will build on top of the template that was generated previously, and develop a smart contract that will function as a To-Do List.",source:"@site/i18n/fr/docusaurus-plugin-content-docs-dev-academy/current/develop-smart-contract/02-develop.md",sourceDirName:"develop-smart-contract",slug:"/develop-smart-contract/develop",permalink:"/fr/dev-academy/develop-smart-contract/develop",draft:!1,editUrl:"https://crowdin.com/project/cosmwasm-docs/fr",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"devAcademy",previous:{title:"Anatomie d'un contrat intelligent",permalink:"/fr/dev-academy/develop-smart-contract/intro"},next:{title:"Introduction",permalink:"/fr/dev-academy/dao-governance/what-is-a-dao"}},l={},d=[{value:"Contract Config &amp; State",id:"contract-config--state",level:2},{value:"Instantiate",id:"instantiate",level:2},{value:"Message Definition",id:"message-definition",level:3},{value:"Instantiation Logic",id:"instantiation-logic",level:3},{value:"Execute",id:"execute",level:2},{value:"Message Definition",id:"message-definition-1",level:3},{value:"Execution Logic",id:"execution-logic",level:3},{value:"- Create New Entry",id:"--create-new-entry",level:3},{value:"- Update Entry",id:"--update-entry",level:3},{value:"- Delete Entry",id:"--delete-entry",level:3},{value:"Query",id:"query",level:2},{value:"Message Definition",id:"message-definition-2",level:3},{value:"Query Logic",id:"query-logic",level:3},{value:"- Query Entry",id:"--query-entry",level:3},{value:"- Query List",id:"--query-list",level:3},{value:"Contract Deployment",id:"contract-deployment",level:2},{value:"Build",id:"build",level:3},{value:"Contract Interaction",id:"contract-interaction",level:2},{value:"Challenge",id:"challenge",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"developing-a-smart-contract"},"Developing a Smart Contract"),(0,r.kt)("p",null,"In this section, we will build on top of the template that was generated ",(0,r.kt)("a",{parentName:"p",href:"/fr/dev-academy/develop-smart-contract/intro"},"previously"),", and develop a smart contract that will function as a To-Do List. :::tip Reminder\nThe template contract is only being utilized to provide the initial structure. The various functions, messages and data structures that are defined in the template contract will need to be repurposed, replaced or removed in accordance with the needs of our new contract.\n:::"),(0,r.kt)("p",null,"Here is the application logic:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The owner of the To-Do List contract can add new entries, update existing ones or delete them."),(0,r.kt)("li",{parentName:"ul"},"The contract can be queried to return individual entries as well as a subset of the whole list.")),(0,r.kt)("p",null,"You can find the full version of this contract by clicking on the following link:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/InterWasm/cw-contracts/tree/main/contracts"},"cw-contracts/cw-to-do-list"))),(0,r.kt)("h2",{id:"contract-config--state"},"Contract Config & State"),(0,r.kt)("p",null,"Each instance of the To-Do List contract should have an ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," with entry manipulation rights. In order to be able to check whether a function call is authorized or not, the address of the owner must be persisted on contract storage following the instantiation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//state.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n  pub owner: Addr,\n}\n\npub const CONFIG: Item<Config> = Item::new("config");\n//Item stores a single variable of a given type, identified by a string storage key.\n')),(0,r.kt)("p",null,"A To-Do List consists of entries, each of which is identified by a unique ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," of the latest entry on the list is stored as ",(0,r.kt)("inlineCode",{parentName:"p"},"ENTRY_SEQ"),", an Item that holds an integer value. The value stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"ENTRY_SEQ")," is incremented every time a new entry is appended to the list."),(0,r.kt)("p",null,"The attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"status")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"priority")," are defined as enums to provide uniformity among different entries."),(0,r.kt)("p",null,"The list of entries as a whole is persisted as the ",(0,r.kt)("inlineCode",{parentName:"p"},"LIST"),", a Map that holds a collection of ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Entry")," pairs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//state.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Entry {\n    pub id: u64,\n    pub description: String,\n    pub status: Status,\n    pub priority: Priority,\n}\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub enum Status {\n    ToDo,\n    InProgress,\n    Done,\n    Cancelled\n}\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub enum Priority {\n    None,\n    Low,\n    Medium,\n    High\n}\n\npub const ENTRY_SEQ: Item<u64> = Item::new("entry_seq");\npub const LIST: Map<u64, Entry> = Map::new("list");\n')),(0,r.kt)("h2",{id:"instantiate"},"Instantiate"),(0,r.kt)("h3",{id:"message-definition"},"Message Definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// msg.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub owner: Option<String>,\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"owner")," is defined as an optional attribute. If no owner information is provided in the ",(0,r.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," received, the address that instantiates the contract will be assigned as the owner by default."),(0,r.kt)("h3",{id:"instantiation-logic"},"Instantiation Logic"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let owner = msg\n        .owner\n        .and_then(|addr_string| deps.api.addr_validate(addr_string.as_str()).ok())\n        .unwrap_or(info.sender);\n    // If the instantiation message contains an owner address, validate the address and use it.\n    // Otherwise, the owner is the address that instantiates the contract.    \n\n    let config = Config {\n        owner: owner.clone()\n    };\n    // Save the owner address to contract storage.\n    CONFIG.save(deps.storage, &config)?;\n    // Save the entry sequence to contract storage, starting from 0.\n    ENTRY_SEQ.save(deps.storage, &0u64)?;\n\n    Ok(Response::new()\n        .add_attribute("method", "instantiate")\n        .add_attribute("owner", owner))\n}\n')),(0,r.kt)("p",null,"Once again, the logic above dictates that if the ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," in the instantiation message is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some"),", validate and use it; if not, use ",(0,r.kt)("inlineCode",{parentName:"p"},"info.sender")," instead and store the configuration before returning a ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," with the relevant attributes. :::info"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let owner = msg.owner\n    .and_then(|addr_string| deps.api.addr_validate(addr_string.as_str()).ok())\n    .unwrap_or(info.sender);\n")),(0,r.kt)("p",null,"The example above is a great one to understand the concept of method chaining."),(0,r.kt)("p",null,"A great read on the subject: ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/error/option_unwrap/and_then.html"},"Rust Combinators: and_then")," :::"),(0,r.kt)("h2",{id:"execute"},"Execute"),(0,r.kt)("h3",{id:"message-definition-1"},"Message Definition"),(0,r.kt)("p",null,"The owner of the To-Do List contract should be able to add new entries to the list, update existing ones or delete the entries on the list. Therefore, the ExecuteMsg enum should include a struct for each of these actions to later route a received execution message to the appropriate handling logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//msg.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n    NewEntry {description: String, priority: Option<Priority>},\n    UpdateEntry { id: u64, description: Option<String>, status: Option<Status>, priority: Option<Priority> },\n    DeleteEntry { id: u64 }\n}\n')),(0,r.kt)("h3",{id:"execution-logic"},"Execution Logic"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()")," function ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/flow_control/match.html"},"match"),"es the received ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," with one of the structs defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs")," and routes it to the corresponding handler function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::NewEntry {description, priority} => execute_create_new_entry(deps, info, description, priority),\n        ExecuteMsg::UpdateEntry {id, description, status, priority } => execute_update_entry(deps, info, id, description, status, priority),\n        ExecuteMsg::DeleteEntry {id} => execute_delete_entry(deps, info, id)\n    }\n}\n')),(0,r.kt)("h3",{id:"--create-new-entry"},"- Create New Entry"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"execute_create_new_entry()")," handles the creation of a new entry on the list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\npub fn execute_create_new_entry(deps: DepsMut, info: MessageInfo, description: String, priority: Option<Priority>) -> Result<Response, ContractError> {\n    // Before creating the new entry, the function checks if the message sender is \n    // the owner of the contract.\n    let owner = CONFIG.load(deps.storage)?.owner;\n    if info.sender != owner {\n        // If not, it returns an error and the new entry creation fails to be performed.\n        return Err(ContractError::Unauthorized {});\n    }\n    // In order to generate a unique `id` for the new entry, the function increments the entry sequence \n    // and saves it to the contract storage with `ENTRY_SEQ.update()`.\n    let id = ENTRY_SEQ.update::<_, cosmwasm_std::StdError>(deps.storage, |id| {\n        Ok(id.add(1))\n    })?;\n    /*\n       The new entry is defined with the received `description` and `priority` attributes. The `status` of \n       the new entry is set to `ToDo` by default. Notice that `priority` is an optional parameter. \n       If not provided, the \'priority\' will be set as `None` by default.\n    */\n    let new_entry = Entry {\n        id,\n        description,\n        priority: priority.unwrap_or(Priority::None),\n        status: Status::ToDo\n    };\n    // The function finally saves the new entry to the `LIST` with the matching `id` and returns a `Response`\n    // with the relevant attributes. \n    LIST.save(deps.storage, id, &new_entry)?;\n    Ok(Response::new().add_attribute("method", "execute_create_new_entry")\n        .add_attribute("new_entry_id", id.to_string()))\n}\n')),(0,r.kt)("h3",{id:"--update-entry"},"- Update Entry"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"execute_update_entry()")," handles the update of an existing entry on the list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\npub fn execute_update_entry(deps: DepsMut, info: MessageInfo, id: u64, description: Option<String>, status: Option<Status>, priority: Option<Priority>) -> Result<Response, ContractError> {\n    // Before continuing with the new update, the function checks if the message sender is \n    // the owner of the contract.\n    let owner = CONFIG.load(deps.storage)?.owner;\n    if info.sender != owner {\n        // If not, it returns an error and the update fails to be performed.\n        return Err(ContractError::Unauthorized {});\n    }\n    // The entry with the matching `id` is loaded from the `LIST`.\n    let entry = LIST.load(deps.storage, id)?;\n    /*\n       Sharing the same id, an updated version of the entry is defined with the received values for \n       `description`, `status` and `priority`. These are optional parameters and if any one of them is not \n       provided, the function defaults back to the corresponding value from the entry loaded.\n    */\n    let updated_entry = Entry {\n        id,\n        description: description.unwrap_or(entry.description),\n        status: status.unwrap_or(entry.status),\n        priority: priority.unwrap_or(entry.priority),\n    };\n    // The function saves the updated entry to the `LIST` with the matching `id` and returns a `Response` \n    // with the relevant attributes.\n    LIST.save(deps.storage, id, &updated_entry)?;\n    Ok(Response::new().add_attribute("method", "execute_update_entry")\n                      .add_attribute("updated_entry_id", id.to_string()))\n}\n')),(0,r.kt)("h3",{id:"--delete-entry"},"- Delete Entry"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"execute_delete_entry()")," handles the removal of an existing entry from the list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\npub fn execute_delete_entry(deps: DepsMut, info: MessageInfo, id: u64) -> Result<Response, ContractError> {\n    // Before carrying on with the removal, the function checks if the message sender is \n    // the owner of the contract.\n    let owner = CONFIG.load(deps.storage)?.owner;\n    if info.sender != owner {\n        // If not, it returns an error and the deletion fails to be performed.\n        return Err(ContractError::Unauthorized {});\n    }\n    // The entry with the matching `id` is removed from the `LIST`.\n    LIST.remove(deps.storage, id);\n    // The function returns a `Response` with the relevant attributes.\n    Ok(Response::new().add_attribute("method", "execute_delete_entry")\n                      .add_attribute("deleted_entry_id", id.to_string()))\n}\n')),(0,r.kt)("h2",{id:"query"},"Query"),(0,r.kt)("h3",{id:"message-definition-2"},"Message Definition"),(0,r.kt)("p",null,"Upon creating and populating the list with entries, querying individual entries or a subset of the whole list should be possible. Therefore, the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs")," should include a ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg")," enum that defines a struct for each query type to be received, along with the corresponding response message definition for each query type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//msg.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum QueryMsg {\n    QueryEntry {id: u64},\n    QueryList {start_after: Option<u64>, limit: Option<u32>},\n}\n\n// A custom struct is defined for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct EntryResponse {\n    pub id: u64,\n    pub description: String,\n    pub status: Status,\n    pub priority: Priority,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ListResponse {\n    pub entries: Vec<Entry>,\n}\n')),(0,r.kt)("h3",{id:"query-logic"},"Query Logic"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"query()")," function matches the received ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg")," with one of the structs defined in the file /src/msg.rs, routes it to the corresponding handler function and returns a query response in byte-array format."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::QueryEntry { id } => to_binary(&query_entry(deps, id)?),\n        QueryMsg::QueryList {start_after, limit} => to_binary(&query_list(deps, start_after, limit)?),\n    }\n}\n')),(0,r.kt)("h3",{id:"--query-entry"},"- Query Entry"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"query_entry()")," handles the query of an individual existing entry on the list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn query_entry(deps: Deps, id: u64) -> StdResult<EntryResponse> {\n    // The entry with the matching `id` is loaded from the `LIST`.\n    let entry = LIST.load(deps.storage, id)?;\n    // An `EntryResponse` is formed with the attributes of the loaded entry and returned.\n    Ok(EntryResponse { id: entry.id, description: entry.description, status: entry.status, priority: entry.priority })\n}\n")),(0,r.kt)("h3",{id:"--query-list"},"- Query List"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"query_list()")," handles the queries that demand a subset of the whole list. Making use of ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/cw-storage-plus/0.13.2/cw_storage_plus/struct.Map.html"},"Map"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"range()")," function, custom range queries are possible on the stored list of entries."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//contract.rs\n// Limits for the custom range query\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\n\nfn query_list(deps: Deps,\n              start_after: Option<u64>,\n              limit: Option<u32>,\n) -> StdResult<ListResponse> {\n    // The optional parameters `start_after` and `limit` are used to define the subset of the list in order to\n    // limit the number of entries returned.\n\n    // `start_after` serves as the lower index bound for the `range()` function.\n    let start = start_after.map(Bound::exclusive);\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    /*\n       The function `take(limit)` determines the maximum number of entries to be returned. \n       * If a `limit` is not provided, the function defaults to return a maximum of 10 entries. \n       * If a `limit` is provided, the `limit` gets compared with the `MAX_LIMIT` and the smaller of the two is \n         used as the maximum number of entries to be returned.\n    */\n    let entries: StdResult<Vec<_>> = LIST\n        .range(deps.storage, start, None, Order::Ascending)\n        .take(limit)\n        .collect();\n    // The `range().take(limit).collect()` method-chain outputs the result as a vector of (id, Entry) tuples.    \n    let result = ListResponse {\n        entries: entries?.into_iter().map(|l| l.1.into()).collect(),\n    };\n    // The output is then mapped into an Entry-only vector in order to prepare the `ListResponse` struct \n    // that will be returned as the query response.\n    Ok(result)\n}\n")),(0,r.kt)("h2",{id:"contract-deployment"},"Contract Deployment"),(0,r.kt)("p",null,"Now that the main components of the smart contract are defined, the next step is to build and deploy our To-Do List contract to the chain."),(0,r.kt)("h3",{id:"build"},"Build"),(0,r.kt)("p",null,"In order to build the contract and optimize the .wasm binary before deployment, we can follow ",(0,r.kt)("a",{parentName:"p",href:"/dev-academy/develop-smart-contract/intro#building-the-contract"},"the instructions")," that was included in the previous chapter."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"Reminder Because we've used the template contract as a starting point, there might be remnants of the template code that interfere with the build process causing compilation warnings and errors (e.g., unresolved imports) which should be trivial to solve. Still, if you are having problems at this point, please refer to the full version of the contract code ",(0,r.kt)("a",{parentName:"mdxAdmonitionTitle",href:"https://github.com/InterWasm/cw-contracts/tree/main/contracts"},"here")," for a working example. :::"),(0,r.kt)("h3",{parentName:"admonition",id:"deploy"},"Deploy"),(0,r.kt)("p",{parentName:"admonition"},"Once the .wasm binary is built and optimized, we can deploy the contract to the testnet.")),(0,r.kt)("p",null,"You may ignore this step if you have already set up ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmd")," and requested some ",(0,r.kt)("inlineCode",{parentName:"p"},"umlg"),"s for your wallet address from the faucet. :::"),(0,r.kt)("p",null,"Open up a terminal window and navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/artifacts")," folder located in the project root directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"#Deploy the contract to the testnet\nRES=$(wasmd tx wasm store cw_to_do_list.wasm --from wallet --node https://rpc.malaga-420.cosmwasm.com:443 --chain-id malaga-420 --gas-prices 0.25umlg --gas auto --gas-adjustment 1.3 -y --output json -b block)\n\n#Get the Code Id\necho $RES | jq -r '.logs[0].events[-1].attributes[0].value'\n")),(0,r.kt)("p",null,"Using this Code Id, any address can instantiate the contract and create their own To-Do List instance."),(0,r.kt)("h2",{id:"contract-interaction"},"Contract Interaction"),(0,r.kt)("p",null,"Now that the contract is deployed to the testnet with a Code Id, it is time to instantiate the contract and interact with our own To-Do List contract instance."),(0,r.kt)("p",null,"Open up a new Terminal window and run the following command to initialize a CosmJS CLI session."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx @cosmjs/cli@^0.28.1 --init https://raw.githubusercontent.com/InterWasm/cw-plus-helpers/main/base.ts\n")),(0,r.kt)("p",null,"Let us import the necessary ",(0,r.kt)("inlineCode",{parentName:"p"},"StdFee")," interface and generate/load a wallet address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { StdFee } from "@cosmjs/stargate";\n\nconst [addr, client] = await useOptions(malagaOptions).setup("password");\n\n//Display the wallet address\nclient.getAccount(addr);\n//Display the account balance\nclient.getBalance(addr,"umlg")\n')),(0,r.kt)("p",null,"Define a ",(0,r.kt)("inlineCode",{parentName:"p"},"defaultFee")," to be passed into instantiation and execution functions later on:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const defaultFee: StdFee = { amount: [{amount: "200000", denom: "umlg",},], gas: "200000",};\n')),(0,r.kt)("p",null,"We can now instantiate the contract and create a To-Do List instance using the code id we have received upon deployment. Notice that the instantiation message is empty (i.e., ",(0,r.kt)("inlineCode",{parentName:"p"},"{}"),") and does not specify an ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," address. In this case, the contract will be instantiated with our wallet address assigned as the contract ",(0,r.kt)("inlineCode",{parentName:"p"},"owner"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const codeId = 1 //Replace the Code Id with the one you have received earlier\nconst instantiateResponse = await client.instantiate(addr, codeId, {}, "To Do List", defaultFee)\nconsole.log(instantiateResponse)\n')),(0,r.kt)("p",null,"The instantiation should succeed and we should have a response similar to the one below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  contractAddress: 'wasm1mls5039qaptduck4c33h39f4nvl603dkx6xxetclnefdderf2ngsta4tuf',\n  logs: [ { msg_index: 0, log: '', events: [Array] } ],\n  transactionHash: '8CF7CFFDF83EF3553561675AAC49331FB16CAF74A85841D8E7CF8B60DBB5EEBA'\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"contractAddress")," is the address of the contract instance that we have created. We can now include this address in execute and query messages in order to target this specific To-Do List instance. :::note For the remainder of this section, the contract address will be passed into the execute() and query() functions as ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiateResponse.contractAddress"),". If you want to access the same contract instance in the future, it is recommended that you note the contract address down so that the next time you initialize a CosmJS CLI session, you can store the address in a variable (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},'const myOldContract = "The contract address you noted down"'),") and use that variable instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiateResponse.contractAddress")," as a function parameter to target this particular contract instance without the need of re-instantiating a new one. :::"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"transactionHash")," can be carried over to the ",(0,r.kt)("a",{parentName:"p",href:"https://block-explorer.malaga-420.cosmwasm.com/"},"Malaga-420 Block Explorer")," to examine the transaction for the instantiation in detail."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"logs"),", among other details, include the attributes we've added to the ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiate()")," function response in the contract code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'//contract.rs\nOk(Response::new()\n        .add_attribute("method", "instantiate")\n        .add_attribute("owner", owner))\n')),(0,r.kt)("p",null,"At this point the ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," address can be extracted from the ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")," and should match your wallet address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"console.log(instantiateResponse.logs[0].events[2].attributes[2])\n//Outputs the address of the contract owner\n\nclient.getAccount(addr);\n//Outputs your wallet details\n")),(0,r.kt)("p",null,"Now, let us create a new To-Do List entry. Notice that the execute() function targets the contract address we've received upon instantiation and the message inside matches the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg::NewEntry")," that was defined in the contract code under ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'//Enable REPL editor mode to edit multiple lines of code\n.editor\n\nconst executeResponse = await client.execute(\n         addr, \n         instantiateResponse.contractAddress,\n         {\n           new_entry: {\n             description: "A new entry.",\n             priority: "Medium"\n           }\n         },\n         defaultFee,\n       )\n\n//Exit editor using `^D` to execute the code entered\n^D\n\nconsole.log(executeResponse)\n')),(0,r.kt)("p",null,"The executeResponse should look similar to the one below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  logs: [ { msg_index: 0, log: '', events: [Array] } ],\n  transactionHash: '591830F0805C620336CC9E1A66DBCF34BA5ECF5415C4B41EC21112EEDF513510'\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"transactionHash")," can again be carried over to the ",(0,r.kt)("a",{parentName:"p",href:"https://block-explorer.malaga-420.cosmwasm.com/"},"Malaga-420 Block Explorer")," to examine the transaction for the execution in detail."),(0,r.kt)("p",null,"Now, let us query the To-Do List contract and examine the response."),(0,r.kt)("p",null,"Notice that the message inside the query() function matches the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg::QueryList")," that was defined in the contract code under ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),". We are not utilizing the optional ",(0,r.kt)("inlineCode",{parentName:"p"},"start_after")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"limit")," parameters as we do not need to paginate a list that only has a single entry at this point."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const queryResult = await client.queryContractSmart(instantiateResponse.contractAddress, { query_list: {} })\n\nconsole.log(queryResult)\n")),(0,r.kt)("p",null,"The query result should be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entries: [\n    {\n      id: '1',\n      description: 'A new entry.',\n      status: 'ToDo',\n      priority: 'Medium'\n    }\n  ]\n}\n")),(0,r.kt)("p",null,"Create another entry by calling the execute() function again with the message inside matching the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg:NewEntry")," struct."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'//Enable REPL editor mode to edit multiple lines of code\n.editor\n\nconst executeResponse_2 = await client.execute(\n         addr, \n         instantiateResponse.contractAddress,\n         {\n           new_entry: {\n             description: "Another entry.",\n             priority: "Low"\n           }\n         },\n         defaultFee,\n       )\n\n//Exit editor using `^D` to execute the code entered\n^D\n')),(0,r.kt)("p",null,"If we query the list, we should now see two entries."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const queryResult_2 = await client.queryContractSmart(instantiateResponse.contractAddress, { query_list: {} })\n\nconsole.log(queryResult_2)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entries: [\n    {\n      id: '1',\n      description: 'A new entry.',\n      status: 'ToDo',\n      priority: 'Medium'\n    },\n    {\n      id: '2',\n      description: 'Another entry.',\n      status: 'ToDo',\n      priority: 'Low'\n    }\n  ]\n}\n")),(0,r.kt)("p",null,"Let us update the second entry now. Notice that the message inside the execute() function matches the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg:UpdateEntry")," struct that was defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'.editor\nconst executeResponse_3 = await client.execute(\n         addr,\n         instantiateResponse.contractAddress,\n         {\n           update_entry: {\n            id: 2,\n            description: "Updated entry.",\n            priority: "High",\n            status: "InProgress"\n          }\n         },\n         defaultFee,\n       )\n//Exit editor using `^D` to execute the code entered\n^D       \n')),(0,r.kt)("p",null,"Query the second entry individually and see the changes. Notice that the message inside the query() function now matches the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg::QueryEntry")," that was defined in the contract code under ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const queryResult_3 = await client.queryContractSmart(instantiateResponse.contractAddress, {query_entry:{id: 2}})\n\nconsole.log(queryResult_3)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  id: '2',\n  description: 'Updated entry.',\n  status: 'InProgress',\n  priority: 'High'\n}\n")),(0,r.kt)("p",null,"Now, let us delete the first entry. Notice that the message inside the execute() function now matches the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg:DeleteEntry")," struct that was defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},".editor\nconst executeResponse_4 = await client.execute(\n         addr,\n         instantiateResponse.contractAddress,\n         {\n           delete_entry: {\n            id: 1\n          }\n         },\n         defaultFee,\n       )\n//Exit editor using `^D` to execute the code entered\n^D\n")),(0,r.kt)("p",null,"Query the list again and see that the first entry has been deleted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const queryResult_4 = await client.queryContractSmart(instantiateResponse.contractAddress, { query_list: {} })\n\nconsole.log(queryResult_4)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entries: [\n    {\n      id: '2',\n      description: 'Updated entry.',\n      status: 'InProgress',\n      priority: 'High'\n    }\n  ]\n}\n")),(0,r.kt)("p",null,"With that, we've covered the basic functionality of our To-Do List contract."),(0,r.kt)("p",null,"Do not exit the CosmJS CLI session yet, so that we can create a different wallet address (i.e., one that is not the owner of our contract instance) and try to append a new entry to our To-Do list."),(0,r.kt)("p",null,"Now, running the command below will create a new key file containing an encrypted mnemonic in your ",(0,r.kt)("inlineCode",{parentName:"p"},"HOME")," directory (i.e., ~/.another.key) and generate a new wallet address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const [another_addr, another_client] = await useOptions(malagaOptions).setup("password", ".another.key" );\n')),(0,r.kt)("p",null,"You may compare the wallet addresses at hand with the following commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"//The original wallet address for the contract owner\nclient.getAccount(addr)\n\n//The new wallet address that is not the contract owner\nanother_client.getAccount(another_addr)\n")),(0,r.kt)("p",null,"Now, we can try and create a new entry. Notice that, although the target contract address remains the same, we are now utilizing ",(0,r.kt)("inlineCode",{parentName:"p"},"another_client")," to call the execute() function with ",(0,r.kt)("inlineCode",{parentName:"p"},"another_addr")," as the sender address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'//Enable REPL editor mode to edit multiple lines of code\n.editor\n\nconst executeResponse_5 = await another_client.execute(\n         another_addr, \n         instantiateResponse.contractAddress,\n         {\n           new_entry: {\n             description: "A new entry attempt from a wallet address that is not the contract owner.",\n             priority: "Medium"\n           }\n         },\n         defaultFee,\n       )\n\n//Exit editor using `^D` to execute the code entered\n^D\n')),(0,r.kt)("p",null,"The response is expected to be similar to the one below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Error: Error when broadcasting tx EA5DFED64B966CDF839E2FAA8310CB4B7D541368BB1AAF8E7F68CEA4A9BE0BE2  at height 1995608. \nCode: 5; Raw log: failed to execute message; message index: 0: Unauthorized: execute wasm contract failed\n")),(0,r.kt)("p",null,"Because ",(0,r.kt)("inlineCode",{parentName:"p"},"another_addr")," is not the owner of our contract instance, the following portion of our contract code returns the error message that corresponds to ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractError::Unauthorized {}")," defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/error.rs"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"//contract.rs\npub fn execute_create_new_entry(deps: DepsMut, info: MessageInfo, description: String, priority: Option<Priority>) -> \nResult<Response, ContractError> {\n    let owner = CONFIG.load(deps.storage)?.owner;\n    if info.sender != owner {\n        return Err(ContractError::Unauthorized {});\n    }\n    ...\n}\n")),(0,r.kt)("p",null,"You may now exit the CosmJS CLI session with the command ",(0,r.kt)("inlineCode",{parentName:"p"},".exit"),"."),(0,r.kt)("h2",{id:"challenge"},"Challenge"),(0,r.kt)("p",null,"Modify the To-Do List contract so that the contract owner is able to"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"transfer the ownership of the contract to another address.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"set a due date for each To-Do List entry."))))}u.isMDXComponent=!0}}]);