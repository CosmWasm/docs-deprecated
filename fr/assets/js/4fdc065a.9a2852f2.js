"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1773],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6234:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={title:"Smart contract as an actor"},s="Smart contract as an actor",r={unversionedId:"actor-model/actor-in-blokchain",id:"actor-model/actor-in-blokchain",title:"Smart contract as an actor",description:"In previous chapters, we were talking about the actor model and how is it",source:"@site/docs/05-actor-model/03-actor-in-blokchain.md",sourceDirName:"05-actor-model",slug:"/actor-model/actor-in-blokchain",permalink:"/fr/docs/actor-model/actor-in-blokchain",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Smart contract as an actor"},sidebar:"defaultSidebar",previous:{title:"Actors in blockchain",permalink:"/fr/docs/actor-model/actors-in-blockchain"},next:{title:"CosmWasm IDE Tutorial",permalink:"/fr/docs/tutorials/cosmwasm-ide"}},l={},p=[{value:"The state",id:"state",level:2},{value:"Messages",id:"messages",level:2},{value:"Entry points",id:"entry-points",level:2},{value:"Sending submessages",id:"sending-submessages",level:2},{value:"CosmosMsg",id:"cosmos-msg",level:2},{value:"Reply handling",id:"reply",level:2},{value:"Migrations",id:"migration",level:2},{value:"Sudo",id:"sudo",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"smart-contract-as-an-actor"},"Smart contract as an actor"),(0,i.kt)("p",null,"In previous chapters, we were talking about the actor model and how is it\nimplemented in the blockchain. Now it is time to look closer into the typical\ncontract structure to understand how different features of the actor model\nare mapped to it."),(0,i.kt)("p",null,"This will not be a step-by-step guide on contract creation, as it is a topic\nfor the series itself. It would be going through contract elements roughly to\nvisualize how to handle architecture in the actor model."),(0,i.kt)("p",null,"An explanation how are CosmWasm execution performed can be found in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/blob/main/SEMANTICS.md"},"SEMANTICS.md"),",\nhere I will try to explain it step by step."),(0,i.kt)("h2",{id:"state"},"The state"),(0,i.kt)("p",null,"As before we would start with the state. Previously we were working with\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"tg4-group")," contract, so let's start by looking at its code. Go to\n",(0,i.kt)("inlineCode",{parentName:"p"},"cw-plus/contracts/cw4-group/src"),". The folder structure should look like\nthis:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"}," \uf115 src\n\u251c\u2500\u2500 \ue7a8 contract.rs\n\u251c\u2500\u2500 \ue7a8 error.rs\n\u251c\u2500\u2500 \ue7a8 helpers.rs\n\u251c\u2500\u2500 \ue7a8 lib.rs\n\u251c\u2500\u2500 \ue7a8 msg.rs\n\u2514\u2500\u2500 \ue7a8 state.rs\n")),(0,i.kt)("p",null,"As you may already figure out, we want to check the ",(0,i.kt)("inlineCode",{parentName:"p"},"state.rs")," first."),(0,i.kt)("p",null,"The most important thing here is couple of constants: ",(0,i.kt)("inlineCode",{parentName:"p"},"ADMIN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HOOKS"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"TOTAL"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"MEMBERS"),". Every one of such constants represents a single\nportion of the contract state - as tables in databases. The types of\nthose constants represent what kind of table is this. The most\nbasic ones are ",(0,i.kt)("inlineCode",{parentName:"p"},"Item<T>"),", which keeps zero or one element of a given\ntype, and ",(0,i.kt)("inlineCode",{parentName:"p"},"Map<K, T>")," which is a key-value map."),(0,i.kt)("p",null,"You can see ",(0,i.kt)("inlineCode",{parentName:"p"},"Item")," is used to keep an admin, and some other data:\n",(0,i.kt)("inlineCode",{parentName:"p"},"HOOKS"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TOTAL"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"HOOKS")," is used by the ",(0,i.kt)("inlineCode",{parentName:"p"},"cw4-group")," to allow\nsubscription to any changes to a group - a contract can be added as\na hook, so when the group changes, a message is sent to it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TOTAL"),"\nis just a sum of all members' weights."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MEMBERS")," in the group contract is the ",(0,i.kt)("inlineCode",{parentName:"p"},"SnapshotMap")," - as you can\nimagine it is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),", with some steroids - this particular one,\ngives us access to the state of the map at some point of history,\naccessing it by the blockchain ",(0,i.kt)("inlineCode",{parentName:"p"},"height"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"height")," is the count\nof blocks created since the begging of blockchain, and it is\nthe most atomic time representation in smart contracts. There\nis a way to access the clock time in them, but everything happening\nin a single block is considered happening in the same moment."),(0,i.kt)("p",null,"Other types of storage objects not used in group contracts are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IndexedMap")," - another map type, which allows accessing values\nby a variety of keys"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IndexedSnapshotMap")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"IndexedMap")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"SnapshotMap")," married")),(0,i.kt)("p",null,"What is very important - every state type in the contract is accessed\nusing some name. All of those types are not containers, just accessors\nto the state. Do you remember that I told you before, that blockchain is\nour database? And that is correct! All those types are just ORM to\nthis database - when we will use them to get actual data from it,\nwe would pass a special ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," object to them, so they can retrieve\nitems from it."),(0,i.kt)("p",null,"You may ask - why all those data for a contract are not auto-fetched\nby whatever is running it? That is a good question. The reason is,\nthat we want contracts to be lazy with fetching. Copying data is\na very expensive operation, and for everything happening on it, someone\nhas to pay - it is realized by gas cost. I told you before, that as\na contract developer you don't need to worry about gas at all, but it\nwas only partially true. You don't need to know exactly how gas is\ncalculated, but by lowering your gas cost, you would may execution\nof your contracts cheaper which is typically a good thing. One good\npractice to achieve that is to avoid fetching data you will not use\nin a particular call."),(0,i.kt)("h2",{id:"messages"},"Messages"),(0,i.kt)("p",null,"In a blockchain, contracts communicate with each other by some JSON\nmessages. They are defined in most contracts in the ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.rs")," file. Take\na look at it."),(0,i.kt)("p",null,"There are three types on it, let's go through them one by one.\nThe first one is an ",(0,i.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),". This is the one, which is sent\non contract instantiation. It typically contains some data which\nare needed to properly initialize it. In most cases, it is just a\nsimple structure."),(0,i.kt)("p",null,"Then there are two enums: ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecuteMsg"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryMsg"),". They are\nenums because every single variant of them represents a different\nmessage which can be sent. For example the ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecuteMsg::UpdateAdmin"),"\ncorresponds to the ",(0,i.kt)("inlineCode",{parentName:"p"},"update_admin")," message we were sending previously."),(0,i.kt)("p",null,"Note, that all the messages are attributed with\n",(0,i.kt)("inlineCode",{parentName:"p"},"#[derive(Serialize, Deserialize)]"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},'#[serde(rename_all="snake_case")]'),". Those attributes come from\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://serde.rs/"},"serde")," create, and they help us with\ndeserialization of them (and serialization in case of sending\nthem to other contracts). The second one is not required,\nbut it allows us to keep a camel-case style in our Rust code,\nand yet still have JSONs encoded with a snake-case style more\ntypical to this format."),(0,i.kt)("p",null,"I encourage you to take a closer look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"serde")," documentation,\nlike everything it is there, can be used with the messages."),(0,i.kt)("p",null,"One important thing to notice - empty variants of those enums,\ntends to use the empty brackets, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin {}")," instead of\nmore Rusty ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin"),". It is on purpose, to make JSONs cleaner,\nand it is related to how ",(0,i.kt)("inlineCode",{parentName:"p"},"serde")," serializes enum."),(0,i.kt)("p",null,"Also worth noting is that those message types are not set in stone,\nthey can be anything. This is just a convention, but sometimes\nyou would see things like ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecuteCw4Msg"),", or similar. Just keep\nin mind, to keep your message name obvious in terms of their\npurpose - sticking to ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecuteMsg"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"QueryMsg")," is generally a good\nidea."),(0,i.kt)("h2",{id:"entry-points"},"Entry points"),(0,i.kt)("p",null,"So now, when we have our contract message, we need a way to handle\nthem. They are send to our contract via entry points. There are\nthree entry points in the ",(0,i.kt)("inlineCode",{parentName:"p"},"cw4-group")," contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    // ...\n}\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    // ..\n}\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    // ..\n}\n')),(0,i.kt)("p",null,"Those functions are called by the CosmWasm virtual machine when\na message is to be handled by contract. You can think about them\nas the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function of normal programs, except they have a signature\nthat better describes the blockchain itself."),(0,i.kt)("p",null,"What is very important, is that the names of those entry points (similarly to\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function) are fixed - it is relevant, so the virtual machine knows\nexactly what to call."),(0,i.kt)("p",null,"So let's start with the first line. Every entry point is attributed with\n",(0,i.kt)("inlineCode",{parentName:"p"},'#[cfg_attr(not(feature = "library"), entry_point)]'),". It may look a bit\nscary, but it is just a conditional equivalent of ",(0,i.kt)("inlineCode",{parentName:"p"},"#[entry_point]"),' - the\nthe attribute would be there if and only if the "library" feature is not set.\nWe do this, to be able to use our contracts as dependencies for other\ncontract - the final binary can contain only one copy of each entry point,\nso we make sure, that only the top-level one is compiled without this\nfeature.'),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"entry_point")," attribute is a macro which generates some boilerplate.\nAs the binary is run by WASM virtual machine, it doesn't know much about\nRust types - the actual entry point signatures are very inconvenient to\nuse. To overcome this issue, there is a macro created, which generates\nentry points for us, and those entry points are just calling our functions."),(0,i.kt)("p",null,"Now take a look at functions arguments. Every single entry point takes as\nthe last argument a message which triggered the execution of it (except for\n",(0,i.kt)("inlineCode",{parentName:"p"},"reply")," - I would explain it later). In addition to that, there are\nadditional arguments provided by blockchain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Deps")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"DepsMut")," object is the gateway to the world outside the smart contract context. It allows\naccessing the contract state, as well as querying other contracts, and\nalso delivers an ",(0,i.kt)("inlineCode",{parentName:"li"},"Api")," object with a couple of useful utility functions.\nThe difference is, that ",(0,i.kt)("inlineCode",{parentName:"li"},"DepsMut")," allows updating state, while ",(0,i.kt)("inlineCode",{parentName:"li"},"Deps"),"\nallows only to look at it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Env")," object delivers information about the blockchain state in the\nmoment of execution - its height, the timestamp of execution and information\nabout the executing contract itself."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MessageInfo")," object is information about the contract call - it\ncontains the address which sends the message, and the funds send with the\nmessage.")),(0,i.kt)("p",null,"Keep in mind, that the signatures of those functions are fixed (except\nthe messages type), so you cannot interchange ",(0,i.kt)("inlineCode",{parentName:"p"},"Deps")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"DepsMut")," to\nupdate contract state in the query call."),(0,i.kt)("p",null,"The last portion of entry points is the return type. Every\nentry point returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," type, with any error which can be turned\ninto a string - in case of contract failure, the returned error is just\nlogged. In most cases, the error type is defined for a contract itself,\ntypically using a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/thiserror/latest/thiserror/"},"thiserror"),"\ncrate. ",(0,i.kt)("inlineCode",{parentName:"p"},"Thiserror")," is not required here, but strongly recommended - using\nit makes the error definition very straightforward, and also improves\nthe testability of the contract."),(0,i.kt)("p",null,"The important thing is the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok")," part of ",(0,i.kt)("inlineCode",{parentName:"p"},"Result"),". Let's start with the\n",(0,i.kt)("inlineCode",{parentName:"p"},"query")," because this one is the simplest. The query always returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"Binary"),"\nobject on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok")," case, which would contain just serialized response.\nThe common way to create it is just calling a ",(0,i.kt)("inlineCode",{parentName:"p"},"to_binary")," method\non an object implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"serde::Serialize"),", and they are typically\ndefined in ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.rs")," next to messages types."),(0,i.kt)("p",null,"Slightly more complex is the return type returned by any other entry\npoint - the ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::Response")," type. This one keeps everything\nneeded to complete contract execution. There are three chunks of\ninformation in that."),(0,i.kt)("p",null,"The first one is an ",(0,i.kt)("inlineCode",{parentName:"p"},"events")," field. It contains all events, which would\nbe emitted to the blockchain as a result of the execution. Events have\na really simple structure: they have a type, which is just a string,\nand a list of attributes which are just string-string key-value pairs."),(0,i.kt)("p",null,"You can notice that there is another ",(0,i.kt)("inlineCode",{parentName:"p"},"attributes")," field on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),"\nThis is just for convenience - most executions would return\nonly a single event, and to make it a bit easier to operate one, there\nis a set of attributes directly on response. All of them would be converted\nto a single ",(0,i.kt)("inlineCode",{parentName:"p"},"wasm")," event which would be emitted. Because of that, I consider\n",(0,i.kt)("inlineCode",{parentName:"p"},"events")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"attributes")," to be the same chunk of data."),(0,i.kt)("p",null,"Then we have the messages field, of ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg")," type. This one is the clue\nof cross-contact communication. Those messages would be sent to the\ncontracts after processing. What is important - the whole execution is\nnot finished, unless the processing of all sub-messages scheduled by the contract\nfinishes. So if the group contract sends some messages as a result of\n",(0,i.kt)("inlineCode",{parentName:"p"},"update_members")," execution, the execution would be considered done only if\nall the messages sent by it would also be handled (even if they failed)."),(0,i.kt)("p",null,"So when all the sub-messages sent by contract are processed, then all\nthe attributes generated by all sub calls and top-level calls are collected\nand reported to the blockchain. But there is one additional information -\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"data"),". So this is another ",(0,i.kt)("inlineCode",{parentName:"p"},"Binary")," field, just like the result of a query\ncall, and just like it, it typically contains serialized JSON. Every\ncontract call can return some additional information in any format,\nYou may ask - in this case, why do we even bother returning attributes?\nIt is because of a completely different way of emitting events and\ndata. Any attributes emitted by the contract would be visible on blockchain\neventually (unless the whole message handling fails). So if your contract\nemitted some event as a result of being sub call of some bigger use case,\nthe event would always be there visible to everyone. This is not true for\ndata. Every contract call would return only single ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," chunk, and it\nhas to decide if it would just forward the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," field of one of the\nsub-calls, or maybe it would construct something by itself. I would\nexplain it in a bit more detail in a while."),(0,i.kt)("h2",{id:"sending-submessages"},"Sending submessages"),(0,i.kt)("p",null,"I don't want to go into details of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," API, as it can be\nread directly from documentation, but I want to take a bit closer look\nto the part about sending messages."),(0,i.kt)("p",null,"The first function to use here is ",(0,i.kt)("inlineCode",{parentName:"p"},"add_message"),", which takes as an argument\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg")," (or rather anything convertible to it). Message added\nto response this way, would be sent and processed, and its execution\nwould not affect the result of the contract at all."),(0,i.kt)("p",null,"The other function to use is ",(0,i.kt)("inlineCode",{parentName:"p"},"add_submessage"),", taking a ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg")," argument.\nIt doesn't differ much from ",(0,i.kt)("inlineCode",{parentName:"p"},"add_message")," - ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg")," just wraps the\n",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg"),", adding some info to it: the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field, and ",(0,i.kt)("inlineCode",{parentName:"p"},"reply_on"),".\nThere is also a ",(0,i.kt)("inlineCode",{parentName:"p"},"gas_limit")," thing, but it is not so important - it just\ncauses sub-message processing to fail early if the gas threshold is reached."),(0,i.kt)("p",null,"The simple thing is ",(0,i.kt)("inlineCode",{parentName:"p"},"reply_on")," - it describes if the ",(0,i.kt)("inlineCode",{parentName:"p"},"reply")," message\nshould be sent on processing success, on failure, or both."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field is an equivalent of order id in our KFC example from\nthe very beginning. If you send multiple different sub-messages, it would\nbe impossible to distinguish them without that field. It would not\nbe even possible to figure out, what type of original message is reply\nhandling! This is why the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field is there - sending a sub-message you can\nset it to any value, and then on the reply, you can\nfigure out what is happening based on this field."),(0,i.kt)("p",null,"An important note here - you don't need to worry about some sophisticated\nway of generating ids. Remember, that the whole processing is atomic,\nand only one execution can be in progress at once. In most cases, your contract\nsends a fixed number of sub-messages on very concrete executions. Because\nof that, you can hardcode most of those ids while sending (preferably\nusing some constant)."),(0,i.kt)("p",null,"To easily create sub-messages, instead of setting all the fields\nseparately, you would typically use helper constructors:\n",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg::reply_on_success"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg::reply_on_error")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg::reply_always"),"."),(0,i.kt)("h2",{id:"cosmos-msg"},"CosmosMsg"),(0,i.kt)("p",null,"If you took a look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg")," type, you could be very surprised -\nthere are so many variants of them, and it is not obvious how do they\nrelate to communication with other contracts."),(0,i.kt)("p",null,"The message you are looking for this is the ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmMsg")," (",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg::Wasm"),"\nvariant). This one is very much similar to what we already know -\nit has a couple of variants of operation to be performed by contracts:\n",(0,i.kt)("inlineCode",{parentName:"p"},"Execute"),", but also ",(0,i.kt)("inlineCode",{parentName:"p"},"Instantiate")," (so we can create new contracts\nin contract executions), and also ",(0,i.kt)("inlineCode",{parentName:"p"},"Migrate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateAdmin"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"ClearAdmin")," - those are used to manage migrations (will tell a bit\nabout them at the end of this chapter)."),(0,i.kt)("p",null,"Another interesting message is the ",(0,i.kt)("inlineCode",{parentName:"p"},"BankMsg")," (",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg::Bank"),"). This\none allows a contract to transfer native tokens to other contracts\n(or burn them - equivalent to transferring them to some black whole\ncontract). I like to think about it as sending a message to very\nspecial contract responsible for handling native tokens - this is\nnot a true contract, as it is handled by the blockchain itself,\nbut at least to me it simplifies things."),(0,i.kt)("p",null,"Other variants of ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg")," are not very interesting for now.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"Custom")," one is there to allow other CosmWasm-based blockchains\nto add some blockchain-handled variant of the message. This is\na reason why most message related types in CosmWasm are\ngeneric over some ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," - this is just a blockchain-specific type of\nmessage. We will never use it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmd"),". All other messages are\nrelated to advanced CosmWasm features, and I will not describe them\nhere."),(0,i.kt)("h2",{id:"reply"},"Reply handling"),(0,i.kt)("p",null,"So now that we know how to send sub-message, it is time to talk about\nhandling the reply. When sub-message processing is finished, and it is\nrequested to reply, the contract is called with an entry point:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn reply(deps: DepsMut, env: Env, msg: Reply) -> Result<Response, ContractError> {\n    // ...\n}\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DepsMut"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Env")," arguments are already familiar, but there is\nthe new one, substituting the typical message argument: the\n",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::Reply"),"."),(0,i.kt)("p",null,"This is a type representing the execution status of the sub-message. It is\nslightly processed ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::Response"),". First\nimportant thing it contains, is an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," - the same, which\nyou set sending sub-message, so now you can identify your response.\nThe other one is the ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractResult"),", which is very similar\nto the Rust ",(0,i.kt)("inlineCode",{parentName:"p"},"Result<T, String>")," type, except it is there for serialization\npurposes. You can easily convert it into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Result")," with an ",(0,i.kt)("inlineCode",{parentName:"p"},"into_result"),"\nfunction."),(0,i.kt)("p",null,"In the error case of ",(0,i.kt)("inlineCode",{parentName:"p"},"ContracResult"),", there is a string - as I mentioned\nbefore, errors are converted to string right after execution. The\n",(0,i.kt)("inlineCode",{parentName:"p"},"Ok")," case contains ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsgExecutionResponse")," with two fields:\n",(0,i.kt)("inlineCode",{parentName:"p"},"events")," emitted by sub-call, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," field embedded on response."),(0,i.kt)("p",null,"As said before, you never need to worry about forwarding events -\nCosmWasm would do it anyway. The ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," however is another story.\nAs mentioned before, every call would return only a single data object.\nIn the case of sending sub-messages and not capturing a reply, it would\nalways be whatever is returned by the top-level message. But it is not a case\nwhen ",(0,i.kt)("inlineCode",{parentName:"p"},"reply")," is called. If a reply is called, then it is a function deciding\nabout the final ",(0,i.kt)("inlineCode",{parentName:"p"},"data"),". It can decide to either forward the data from\nthe sub-message (by returning ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),") or to overwrite it. It cannot choose,\nto return data from the original execution processing - if the contract\nsends sub-messages waiting for replies, it is supposed to not return\nany data, unless replies are called."),(0,i.kt)("p",null,"But what happens, if multiple sub-messages are sent? What would the\nfinal ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," contain? The rule is - the last non-None. All sub-messages\nare always called in the order of adding them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),". As\nthe order is deterministic and well defined, it is always easy to predict\nwhich reply would be used."),(0,i.kt)("h2",{id:"migration"},"Migrations"),(0,i.kt)("p",null,"I mentioned migrations earlier when describing the ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmMsg"),". So migration\nis another action possible to be performed by contracts, which is kind\nof similar to instantiate. In software engineering it is a common thing, to\nrelease an updated version of applications. It is also a case in the blockchain -\nSmartContract can be updated with some new features. In such cases, new\ncode is uploaded, and the contract is migrated - so it knows, that from\nthis point, its messages are handled by another, updated contract code."),(0,i.kt)("p",null,"However, it may be, that the contract state used by the older version of the\ncontract differs from the new one. It is not a problem if some info was\nadded (for example some additional map - it would be just empty right\nafter migration). But the problem is, when the state changes,\nfor example, the field is renamed. In such a case, every contract execution\nwould fail because of (de)serialization problems. Or even more subtle\ncases, like adding a map, but one which should be synchronized with the whole\ncontract state, not empty."),(0,i.kt)("p",null,"This is the purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"migration")," entry point. It looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -> Result<Response<T>, ContracError> {\n    // ..\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MigrateMsg")," is the type defined by the contract in ",(0,i.kt)("inlineCode",{parentName:"p"},"msg.rs"),".\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"migrate")," entry point would be called at the moment of performing\nthe migration, and it is responsible for making sure, the state is correct\nafter the migration. It is very similar to schema migrations in traditional\ndatabase applications. And it is also kind of difficult, because of version\nmanagement involved - you can never assume, that you are migrating a contract\nfrom the previous version - it can be migrated from any version, released\nanytime - even later than that version we are migrating to!"),(0,i.kt)("p",null,"It is worth binging back one issue from the past - the contract admin. Do you\nremember the ",(0,i.kt)("inlineCode",{parentName:"p"},"--no-admin")," flag we set previously on every contract instantiation?\nIt made our contract unmigrateable. Migrations can be performed only\nby contract admin. To be able to use it, you should pass ",(0,i.kt)("inlineCode",{parentName:"p"},"--admin address")," flag\ninstead, with ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," being the address which would be able to perform migrations."),(0,i.kt)("h2",{id:"sudo"},"Sudo"),(0,i.kt)("p",null,"Sudo is the last possible entry point in ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmWasm"),", and it is the one we would\nnever use in ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmd"),". It is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg::Custom"),", but instead of\nbeing a special blockchain-specific message to be sent and handled by a blockchain\nitself, it is now a special blockchain-specific message sent by blockchain to\ncontract in some conditions. There are many uses for those, but I will not\ncover of them, because it is not related to ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmWasm")," itself. The signature\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"sudo")," looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -> Result<Response, ContractError> {\n    // ..\n}\n')),(0,i.kt)("p",null,"The important difference is, that because ",(0,i.kt)("inlineCode",{parentName:"p"},"sudo")," messages are blockchain\nspecific, the ",(0,i.kt)("inlineCode",{parentName:"p"},"SudoMsg")," type is typically defined by some blockchain helper\ncrate, not the contract itself."))}d.isMDXComponent=!0}}]);