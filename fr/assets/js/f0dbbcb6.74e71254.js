"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9057],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return c}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(t),c=r,k=u["".concat(l,".").concat(c)]||u[c]||m[c]||i;return t?a.createElement(k,o(o({ref:n},d),{},{components:t})):a.createElement(k,o({ref:n},d))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9150:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return p}});var a=t(3117),r=(t(7294),t(3905));const i={sidebar_position:6},o="Migrating Contracts",s={unversionedId:"MIGRATING",id:"version-0.14/MIGRATING",title:"Migrating Contracts",description:"This guide explains what is needed to upgrade contracts when migrating over major releases of cosmwasm. Note that you",source:"@site/docs_versioned_docs/version-0.14/06-MIGRATING.md",sourceDirName:".",slug:"/MIGRATING",permalink:"/fr/docs/0.14/MIGRATING",draft:!1,editUrl:"https://github.com/InterWasm/docs/edit/main/docs_versioned_docs/version-0.14/06-MIGRATING.md",tags:[],version:"0.14",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"version-0.14/docsSidebar",previous:{title:"Compatibility",permalink:"/fr/docs/0.14/COMPATIBILITY"},next:{title:"CHANGELOG",permalink:"/fr/docs/0.14/CHANGELOG"}},l={},p=[{value:"0.13 -&gt; 0.14",id:"013---014",level:2},{value:"0.12 -&gt; 0.13",id:"012---013",level:2},{value:"0.11 -&gt; 0.12",id:"011---012",level:2},{value:"0.10 -&gt; 0.11",id:"010---011",level:2},{value:"0.9 -&gt; 0.10",id:"09---010",level:2},{value:"0.8 -&gt; 0.9",id:"08---09",level:2},{value:"0.7.2 -&gt; 0.8",id:"072---08",level:2},{value:"Update wasm code",id:"update-wasm-code",level:3},{value:"Update test code",id:"update-test-code",level:3},{value:"Update schema code",id:"update-schema-code",level:3},{value:"Polishing",id:"polishing",level:3}],d={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"migrating-contracts"},"Migrating Contracts"),(0,r.kt)("p",null,"This guide explains what is needed to upgrade contracts when migrating over major releases of ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm"),". Note that you\ncan also view the\n",(0,r.kt)("a",{parentName:"p",href:"/fr/docs/0.14/CHANGELOG"},"complete CHANGELOG")," to understand the differences."),(0,r.kt)("h2",{id:"013---014"},"0.13 -> 0.14"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The minimum Rust supported version for 0.14 is 1.51.0. Verify your Rust version is >= 1.51.0 with: ",(0,r.kt)("inlineCode",{parentName:"p"},"rustc --version"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm and schemars dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.14.0"\ncosmwasm-storage = "0.14.0"\nschemars = "0.8.1"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.14.0"\ncosmwasm-vm = "0.14.0"\n# ...\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename the ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," entry point to ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiate"),". Also, rename ",(0,r.kt)("inlineCode",{parentName:"p"},"InitMsg")," to\n",(0,r.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle")," entry point to ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),". Also, rename ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleMsg")," to\n",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename ",(0,r.kt)("inlineCode",{parentName:"p"},"InitResponse"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleResponse")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MigrateResponse")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Response"),". The old names are still supported (with a\ndeprecation warning), and will be removed in the next version. Also, you'll need to add the ",(0,r.kt)("inlineCode",{parentName:"p"},"submessages")," field\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"Response"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Remove ",(0,r.kt)("inlineCode",{parentName:"p"},"from_address")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"BankMsg::Send"),", which is now automatically filled with the contract address:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// before\nctx.add_message(BankMsg::Send {\n    from_address: env.contract.address,\n    to_address: to_addr,\n    amount: balance,\n});\n\n// after\nctx.add_message(BankMsg::Send {\n    to_address: to_addr,\n    amount: balance,\n});\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use the new entry point system. From ",(0,r.kt)("inlineCode",{parentName:"p"},"lib.rs")," remove"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points!(contract);\n\n// or\n\n#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points_with_migration!(contract);\n')),(0,r.kt)("p",{parentName:"li"},"Then add the macro attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"#[entry_point]")," to your ",(0,r.kt)("inlineCode",{parentName:"p"},"contract.rs")," as follows:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use cosmwasm_std::{entry_point, \u2026 };\n\n// \u2026\n\n#[entry_point]\npub fn init(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: InitMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n#[entry_point]\npub fn execute(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: ExecuteMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n// only if you have migrate\n#[entry_point]\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: MigrateMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n#[entry_point]\npub fn query(_deps: Deps, _env: Env, _msg: QueryMsg) -> StdResult<QueryResponse> {\n    // \u2026\n}\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," field, converting ",(0,r.kt)("inlineCode",{parentName:"p"},"Context")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"Response"),"\nalways succeeds."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\npub fn init(deps: DepsMut, env: Env, info: MessageInfo, msg: InitMsg) -> Result<InitResponse, HackError> {\n    // \u2026\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.try_into()?)\n}\n\n// after\npub fn init(deps: DepsMut, env: Env, info: MessageInfo, msg: InitMsg) -> Result<Response, HackError> {\n    // \u2026\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.into())\n}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"info: MessageInfo")," field from the ",(0,r.kt)("inlineCode",{parentName:"p"},"migrate")," entry point:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Before\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: MigrateMsg,\n) -> StdResult<MigrateResponse> {\n  // ...\n}\n\n// After\npub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -> StdResult<Response> {\n  // ...\n}\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"MessageInfo::funds")," was always empty since ","[MsgMigrateContract]"," does not have a funds field. ",(0,r.kt)("inlineCode",{parentName:"p"},"MessageInfo::sender"),"\nshould not be needed for authentication because the chain checks permissions before calling ",(0,r.kt)("inlineCode",{parentName:"p"},"migrate"),". If the sender's\naddress is needed for anything else, this should be expressed as part of the migrate message."),(0,r.kt)("p",{parentName:"li"},"msgmigratecontract:\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L86-L96"},"https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L86-L96"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add mutating helper methods to ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," that can be used instead of creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"Context")," that is later converted to\na response:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\npub fn handle_impl(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    // ...\n\n    // release counter_offer to creator\n    let mut ctx = Context::new();\n    ctx.add_message(BankMsg::Send {\n        to_address: state.creator,\n        amount: state.counter_offer,\n    });\n\n    // release collateral to sender\n    ctx.add_message(BankMsg::Send {\n        to_address: state.owner,\n        amount: state.collateral,\n    });\n\n    // ..\n\n    ctx.add_attribute("action", "execute");\n    Ok(ctx.into())\n}\n')))),(0,r.kt)("p",null,"  // after\npub fn execute_impl(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n// ..."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'  // release counter_offer to creator\n  let mut resp = Response::new();\n  resp.add_message(BankMsg::Send {\n      to_address: state.creator,\n      amount: state.counter_offer,\n  });\n\n  // release collateral to sender\n  resp.add_message(BankMsg::Send {\n      to_address: state.owner,\n      amount: state.collateral,\n  });\n\n  // ..\n\n  resp.add_attribute("action", "execute");\n  Ok(resp)\n')),(0,r.kt)("p",null,"  }"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\n- Use type `Pair` instead of `KV`\n\n```rust\n// before\nuse cosmwasm_std::KV;\n\n// after\nuse cosmwasm_std::Pair;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If necessary, add a wildcard arm to the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," of now non-exhaustive message types ",(0,r.kt)("inlineCode",{parentName:"p"},"BankMsg"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BankQuery"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"WasmMsg"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"WasmQuery"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"HumanAddr")," has been deprecated in favour of simply ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". It never added any significant safety bonus\nover ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," and was just a marker type. The new type ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr")," was created to hold validated addresses. Those can be\ncreated via\n",(0,r.kt)("inlineCode",{parentName:"p"},"Addr::unchecked"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Api::addr_validate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Api::addr_humanize")," and JSON deserialization. In order to maintain type\nsafety, deserialization into ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr"),"\nmust only be done from trusted sources like a contract's state or a query response. User inputs must be deserialized\ninto ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". This new ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr")," type makes it easy to use human readable addresses in state:"),(0,r.kt)("p",{parentName:"li"},"With pre-validated ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"MessageInfo"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// before\npub struct State {\n    pub owner: CanonicalAddr,\n}\n\nlet state = State {\n    owner: deps.api.canonical_address(&info.sender /* of type HumanAddr */)?,\n};\n")))),(0,r.kt)("p",null,"  // after\npub struct State {\npub owner: Addr,\n}\nlet state = State {\nowner: info.sender.clone() /",(0,r.kt)("em",{parentName:"p"}," of type Addr "),"/,\n};"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\nWith user input in `msg`:\n\n```rust\n// before\npub struct State {\n    pub verifier: CanonicalAddr,\n    pub beneficiary: CanonicalAddr,\n    pub funder: CanonicalAddr,\n}\n\ndeps.storage.set(\n    CONFIG_KEY,\n    &to_vec(&State {\n        verifier: deps.api.canonical_address(&msg.verifier /* of type HumanAddr */)?,\n        beneficiary: deps.api.canonical_address(&msg.beneficiary /* of type HumanAddr */)?,\n        funder: deps.api.canonical_address(&info.sender /* of type HumanAddr */)?,\n    })?,\n);\n\n// after\npub struct State {\n    pub verifier: Addr,\n    pub beneficiary: Addr,\n    pub funder: Addr,\n}\n\ndeps.storage.set(\n    CONFIG_KEY,\n    &to_vec(&State {\n        verifier: deps.api.addr_validate(&msg.verifier /* of type String */)?,\n        beneficiary: deps.api.addr_validate(&msg.beneficiary /* of type String */)?,\n        funder: info.sender /* of type Addr */,\n    })?,\n);\n")),(0,r.kt)("p",null,"  The existing ",(0,r.kt)("inlineCode",{parentName:"p"},"CanonicalAddr")," remains unchanged and can be used in cases in which a compact binary representation is\ndesired. For JSON state this does not save much data (e.g. the bech32 address\ncosmos1pfq05em6sfkls66ut4m2257p7qwlk448h8mysz takes 45 bytes as direct ASCII and 28 bytes when its canonical\nrepresentation is base64 encoded). For fixed length database keys ",(0,r.kt)("inlineCode",{parentName:"p"},"CanonicalAddr")," remains handy though."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"DistributionMsg::SetWithdrawAddress")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"DistributionMsg::WithdrawDelegatorReward"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," was a shorthand for the two distribution messages.\nHowever, it was unintuitive because it did not set the address for one withdraw only but for all following withdrawls.\nSince withdrawls are ",(0,r.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/v0.42/modules/distribution/"},"triggered by different events")," such as validators changing their commission\nrate, an address that was set for a one-time withdrawl would be used for future withdrawls not considered by the\ncontract author."),(0,r.kt)("p",{parentName:"li"},"If the contract never set a withdraw address other than the contract itself\n(",(0,r.kt)("inlineCode",{parentName:"p"},"env.contract.address"),"), you can simply replace ",(0,r.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," with\n",(0,r.kt)("inlineCode",{parentName:"p"},"DistributionMsg::WithdrawDelegatorReward"),". It is then never changed from the default. Otherwise you need to carefully\ntrack what the current withdraw address is. A one-time change can be implemented by emitted 3 messages:"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"SetWithdrawAddress { address: recipient }")," to temporarily change the recipient"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"WithdrawDelegatorReward { validator }")," to do a manual withdrawl from the given validator"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"SetWithdrawAddress { address: env.contract.address.into() }")," to change it back for all future withdrawls"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The block time in ",(0,r.kt)("inlineCode",{parentName:"p"},"env.block.time")," is now a ",(0,r.kt)("inlineCode",{parentName:"p"},"Timestamp")," which stores nanosecond precision. ",(0,r.kt)("inlineCode",{parentName:"p"},"env.block.time_nanos")," was\nremoved. If you need the compnents as before, use"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let seconds = env.block.time.nanos() / 1_000_000_000;\nlet nsecs = env.block.time.nanos() % 1_000_000_000;\n")))),(0,r.kt)("h2",{id:"012---013"},"0.12 -> 0.13"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The minimum Rust supported version for 0.13 is 1.47.0."),(0,r.kt)("p",{parentName:"li"},"Verify your Rust version is >= 1.47.0:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"rustc -V\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.13.0"\ncosmwasm-storage = "0.13.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.13.0"\ncosmwasm-vm = "0.13.0"\n# ...\n')))),(0,r.kt)("h2",{id:"011---012"},"0.11 -> 0.12"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.12.0"\ncosmwasm-storage = "0.12.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.12.0"\ncosmwasm-vm = "0.12.0"\n# ...\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In your contract's ",(0,r.kt)("inlineCode",{parentName:"p"},".cargo/config")," remove ",(0,r.kt)("inlineCode",{parentName:"p"},"--features backtraces"),", which is now available in Rust nightly only:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-diff"},'@@ -1,6 +1,6 @@\n [alias]\n wasm = "build --release --target wasm32-unknown-unknown"\n wasm-debug = "build --target wasm32-unknown-unknown"\n-unit-test = "test --lib --features backtraces"\n+unit-test = "test --lib"\n integration-test = "test --test integration"\n schema = "run --example schema"\n')),(0,r.kt)("p",{parentName:"li"},"In order to use backtraces for debugging, run\n",(0,r.kt)("inlineCode",{parentName:"p"},"RUST_BACKTRACE=1 cargo +nightly unit-test --features backtraces"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Extern")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Deps"),", and radically simplify the\n",(0,r.kt)("inlineCode",{parentName:"p"},"init"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"handle"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"migrate"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"query")," entrypoints. Rather than\n",(0,r.kt)("inlineCode",{parentName:"p"},"&mut Extern<S, A, Q>"),", use ",(0,r.kt)("inlineCode",{parentName:"p"},"DepsMut"),". And instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"&Extern<S, A, Q>"),", use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Deps"),". If you ever pass eg. ",(0,r.kt)("inlineCode",{parentName:"p"},"foo<A: Api>(api: A)")," around, you must now use dynamic trait\npointers: ",(0,r.kt)("inlineCode",{parentName:"p"},"foo(api: &dyn Api)"),". Here is the quick search-replace guide on how to fix ",(0,r.kt)("inlineCode",{parentName:"p"},"contract.rs"),":"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"In production (non-test) code:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<S: Storage, A: Api, Q: Querier>")," => ``"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&mut Extern<S, A, Q>")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"DepsMut")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&Extern<S, A, Q>")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"Deps")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&mut deps.storage")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"deps.storage")," where passing into ",(0,r.kt)("inlineCode",{parentName:"li"},"state.rs")," helpers"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&deps.storage")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"deps.storage")," where passing into ",(0,r.kt)("inlineCode",{parentName:"li"},"state.rs")," helpers")),(0,r.kt)("p",{parentName:"li"},"On the top, remove ",(0,r.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Api, Extern, Querier, Storage}"),". Add\n",(0,r.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Deps, DepsMut}"),"."),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"In test code only:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&mut deps,")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"deps.as_mut(),")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&deps,")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"deps.as_ref(),"))),(0,r.kt)("p",{parentName:"li"},"You may have to add ",(0,r.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Storage}")," if the compile complains about the trait"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"If you use cosmwasm-storage, in ",(0,r.kt)("inlineCode",{parentName:"em"},"state.rs"),":")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<S: Storage>")," => ``"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<S: ReadonlyStorage>")," => ``"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<S,")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"<")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&mut S")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"&mut dyn Storage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&S")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"&dyn Storage")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you have any references to ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyStorage")," left after the above, please replace them with ",(0,r.kt)("inlineCode",{parentName:"p"},"Storage")))),(0,r.kt)("h2",{id:"010---011"},"0.10 -> 0.11"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.11.0"\ncosmwasm-storage = "0.11.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.11.0"\ncosmwasm-vm = "0.11.0"\n# ...\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Contracts now support any custom error type ",(0,r.kt)("inlineCode",{parentName:"p"},"E: ToString + From<StdError>"),". Previously this has been ",(0,r.kt)("inlineCode",{parentName:"p"},"StdError"),", which\nyou can still use. However, you can now create a much more structured error experience for your unit tests that\nhandels exactly the error cases of your contract. In order to get a convenient implementation for ",(0,r.kt)("inlineCode",{parentName:"p"},"ToString"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"From<StdError>"),", we use the crate\n",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/thiserror"},"thiserror"),", which needs to be added to the contracts dependencies in ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"\n. To create the custom error, create an error module ",(0,r.kt)("inlineCode",{parentName:"p"},"src/errors.rs")," as follows:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::{CanonicalAddr, StdError};\nuse thiserror::Error;\n\n// thiserror implements Display and ToString if you\n// set the `#[error("\u2026")]` attribute for all cases\n#[derive(Error, Debug)]\npub enum MyCustomError {\n    #[error("{0}")]\n    // let thiserror implement From<StdError> for you\n    Std(#[from] StdError),\n    // this is whatever we want\n    #[error("Permission denied: the sender is not the current owner")]\n    NotCurrentOwner {\n        expected: CanonicalAddr,\n        actual: CanonicalAddr,\n    },\n    #[error("Messages empty. Must reflect at least one message")]\n    MessagesEmpty,\n}\n')),(0,r.kt)("p",{parentName:"li"},"Then add ",(0,r.kt)("inlineCode",{parentName:"p"},"mod errors;")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"src/lib.rs")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"use crate::errors::MyCustomError;"),"\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"src/contract.rs"),". Now adapt the return types as follows:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fn init"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Result<InitResponse, MyCustomError>"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fn migrate")," (if you have it): ",(0,r.kt)("inlineCode",{parentName:"li"},"Result<MigrateResponse, MyCustomError>"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fn handle"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Result<HandleResponse, MyCustomError>"),","),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fn query"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Result<Binary, MyCustomError>"),".")),(0,r.kt)("p",{parentName:"li"},"If one of your funtions does not use the custom error, you can continue to use\n",(0,r.kt)("inlineCode",{parentName:"p"},"StdError")," as before. I.e. you can have ",(0,r.kt)("inlineCode",{parentName:"p"},"handle")," returning\n",(0,r.kt)("inlineCode",{parentName:"p"},"Result<HandleResponse, MyCustomError>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"query")," returning\n",(0,r.kt)("inlineCode",{parentName:"p"},"StdResult<Binary>"),"."),(0,r.kt)("p",{parentName:"li"},"You can have a top-hevel ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"migrate"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"handle"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"query")," that returns a custom error but some of its implementations\nonly return errors from the standard library (",(0,r.kt)("inlineCode",{parentName:"p"},"StdResult<HandleResponse>")," aka.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Result<HandleResponse, StdError>"),"). Then use ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok(std_result?)")," to convert between the result types. E.g."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn handle<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: HandleMsg,\n) -> Result<HandleResponse, StakingError> {\n    match msg {\n        // conversion to Result<HandleResponse, StakingError>\n        HandleMsg::Bond {} => Ok(bond(deps, env)?),\n        // this already returns Result<HandleResponse, StakingError>\n        HandleMsg::_BondAllTokens {} => _bond_all_tokens(deps, env),\n    }\n}\n")),(0,r.kt)("p",{parentName:"li"},"or"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: InitMsg,\n) -> Result<InitResponse, HackError> {\n    // \u2026\n\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.try_into()?)\n}\n')),(0,r.kt)("p",{parentName:"li"},"Once you got familiar with the concept, you can create different error types for each of the contract's functions."),(0,r.kt)("p",{parentName:"li"},"You can also try a different error library than\n",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/thiserror"},"thiserror"),". The\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/tree/master/contracts/staking"},"staking development contract"),"\nshows how this would look like using ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/snafu"},"snafu"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Change order of arguments such that ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," is always first followed by namespace in ",(0,r.kt)("inlineCode",{parentName:"p"},"Bucket::new"),"\n, ",(0,r.kt)("inlineCode",{parentName:"p"},"Bucket::multilevel"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyBucket::new"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyBucket::multilevel"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"PrefixedStorage::new"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"PrefixedStorage::multilevel"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyPrefixedStorage::new"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"ReadonlyPrefixedStorage::multilevel"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bucket"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bucket_read"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"prefixed")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"prefixed_read"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut bucket = bucket::<_, Data>(b"data", &mut store);\n\n// after\nlet mut bucket = bucket::<_, Data>(&mut store, b"data");\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename ",(0,r.kt)("inlineCode",{parentName:"p"},"InitResponse::log"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MigrateResponse::log")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleResponse::log"),"\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"InitResponse::attributes"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MigrateResponse::attributes")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"HandleResponse::attributes"),". Replace calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"attr"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nOk(HandleResponse {\n  log: vec![log("action", "change_owner"), log("owner", owner)],\n  ..HandleResponse::default()\n})\n\n// after\nOk(HandleResponse {\n  attributes: vec![attr("action", "change_owner"), attr("owner", owner)],\n  ..HandleResponse::default()\n})\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rename ",(0,r.kt)("inlineCode",{parentName:"p"},"Context::add_log")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Context::add_attribute"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut ctx = Context::new();\nctx.add_log("action", "release");\nctx.add_log("destination", &to_addr);\n\n// after\nlet mut ctx = Context::new();\nctx.add_attribute("action", "release");\nctx.add_attribute("destination", &to_addr);\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add result type to ",(0,r.kt)("inlineCode",{parentName:"p"},"Bucket::update")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Singleton::update"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nbucket.update(b"maria", |mayd: Option<Data>| {\n  let mut d = mayd.ok_or(StdError::not_found("Data"))?;\n  old_age = d.age;\n  d.age += 1;\n  Ok(d)\n})\n\n// after\nbucket.update(b"maria", |mayd: Option<Data>| -> StdResult<_> {\n  let mut d = mayd.ok_or(StdError::not_found("Data"))?;\n  old_age = d.age;\n  d.age += 1;\n  Ok(d)\n})\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Remove all ",(0,r.kt)("inlineCode",{parentName:"p"},"canonical_length")," arguments from mock APIs in tests:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut deps = mock_dependencies(20, &[]);\nlet mut deps = mock_dependencies(20, &coins(123456, "gold"));\nlet deps = mock_dependencies_with_balances(20, &[(&rich_addr, &rich_balance)]);\nlet api = MockApi::new(20);\n\n// after\nlet mut deps = mock_dependencies(&[]);\nlet mut deps = mock_dependencies(&coins(123456, "gold"));\nlet deps = mock_dependencies_with_balances(&[(&rich_addr, &rich_balance)]);\nlet api = MockApi::default();\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"MessageInfo")," as separate arg after ",(0,r.kt)("inlineCode",{parentName:"p"},"Env")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"handle"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"migrate"),". Add ",(0,r.kt)("inlineCode",{parentName:"p"},"Env")," arg to ",(0,r.kt)("inlineCode",{parentName:"p"},"query"),".\nUse ",(0,r.kt)("inlineCode",{parentName:"p"},"info.sender")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"env.message.sender"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"info.sent_funds")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"env.message.sent_funds"),". Just changing the function signatures of the 3-4 export\nfunctions should be enough, then the compiler will warn you anywhere you use ",(0,r.kt)("inlineCode",{parentName:"p"},"env.message")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// before\npub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: InitMsg,\n) {\n    deps.storage.set(\n        CONFIG_KEY,\n        &to_vec(&State {\n            verifier: deps.api.canonical_address(&msg.verifier)?,\n            beneficiary: deps.api.canonical_address(&msg.beneficiary)?,\n            funder: deps.api.canonical_address(&env.message.sender)?,\n        })?,\n    );\n}\n\n// after\npub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    _env: Env,\n    info: MessageInfo,\n    msg: InitMsg,\n) {\n    deps.storage.set(\n        CONFIG_KEY,\n        &to_vec(&State {\n            verifier: deps.api.canonical_address(&msg.verifier)?,\n            beneficiary: deps.api.canonical_address(&msg.beneficiary)?,\n            funder: deps.api.canonical_address(&info.sender)?,\n        })?,\n    );\n}\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Test code now has ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_info")," which takes the same args ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_env")," used to. You can just pass ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_env()")," directly\ninto the function calls unless you need to change height/time.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"One more object to pass in for both unit and integration tests. To do this quickly, I just highlight all copies\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"env")," and replace them with ",(0,r.kt)("inlineCode",{parentName:"p"},"info"),"\n(using Ctrl+D in VSCode or Alt+J in IntelliJ). Then I select all ",(0,r.kt)("inlineCode",{parentName:"p"},"deps, info"),"\nsections and replace that with ",(0,r.kt)("inlineCode",{parentName:"p"},"deps, mock_env(), info"),". This fixes up all\n",(0,r.kt)("inlineCode",{parentName:"p"},"init")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"handle")," calls, then just add an extra ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_env()")," to the query calls."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before: unit test\nlet env = mock_env(creator.as_str(), &[]);\nlet res = init(&mut deps, env, msg).unwrap();\n\nlet query_response = query(&deps, QueryMsg::Verifier {}).unwrap();\n\n// after: unit test\nlet info = mock_info(creator.as_str(), &[]);\nlet res = init(&mut deps, mock_env(), info, msg).unwrap();\n\nlet query_response = query(&deps, mock_env(), QueryMsg::Verifier {}).unwrap();\n\n// before: integration test\nlet env = mock_env("creator", &coins(1000, "earth"));\nlet res: InitResponse = init(&mut deps, env, msg).unwrap();\n\nlet query_response = query(&mut deps, QueryMsg::Verifier {}).unwrap();\n\n// after: integration test\nlet info = mock_info("creator", &coins(1000, "earth"));\nlet res: InitResponse = init(&mut deps, mock_env(), info, msg).unwrap();\n\nlet query_response = query(&mut deps, mock_env(), QueryMsg::Verifier {}).unwrap();\n')))),(0,r.kt)("h2",{id:"09---010"},"0.9 -> 0.10"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.10.0"\ncosmwasm-storage = "0.10.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.10.0"\ncosmwasm-vm = "0.10.0"\n# ...\n')))),(0,r.kt)("p",null,"Integration tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"Api::human_address")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Api::canonical_address")," now return a pair of result and gas information. Change"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// before\nverifier: deps.api.canonical_address(&verifier).unwrap(),\n\n// after\nverifier: deps.api.canonical_address(&verifier).0.unwrap(),\n")),(0,r.kt)("p",{parentName:"li"},"The same applies for all calls of ",(0,r.kt)("inlineCode",{parentName:"p"},"Querier")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Storage"),"."))),(0,r.kt)("p",null,"All Tests:"),(0,r.kt)("p",null,"All usages of ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_env")," will have to remove the first argument (no need of API)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet env = mock_env( & deps.api, "creator", & coins(1000, "earth"));\n\n// after\nlet env = mock_env("creator", & coins(1000, "earth"));\n')),(0,r.kt)("p",null,"Contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All code that uses ",(0,r.kt)("inlineCode",{parentName:"li"},"message.sender")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"contract.address")," should deal with\n",(0,r.kt)("inlineCode",{parentName:"li"},"HumanAddr")," not ",(0,r.kt)("inlineCode",{parentName:"li"},"CanonicalAddr"),". Many times this means you can remove a conversion step.")),(0,r.kt)("h2",{id:"08---09"},"0.8 -> 0.9"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.9.0"\ncosmwasm-storage = "0.9.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.9.0"\ncosmwasm-vm = "0.9.0"\n# ...\n')))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"lib.rs"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The C export boilerplate can now be reduced to the following code (see e.g. in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/blob/0a5b3e8121/contracts/hackatom/src/lib.rs"},"hackatom/src/lib.rs"),"):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'mod contract; // contains init, handle, query\n// maybe additional modules here\n\n#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points!(contract);\n')))),(0,r.kt)("p",null,"Contract code and uni tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::get_with_prefix"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::set_with_prefix"),",\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::RepLog::commit"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::ReadonlyStorage::get"),",\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::ReadonlyStorage::range"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Storage::set")," and\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Storage::remove")," now return the value directly that was wrapped in a result before."),(0,r.kt)("li",{parentName:"ul"},"Error creator functions are now in type itself, e.g.\n",(0,r.kt)("inlineCode",{parentName:"li"},"StdError::invalid_base64")," instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"invalid_base64"),". The free functions are deprecated and will be removed before\n1.0."),(0,r.kt)("li",{parentName:"ul"},"Remove ",(0,r.kt)("inlineCode",{parentName:"li"},"InitResponse.data")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"init"),". Before 0.9 this was not stored to chain but ignored."),(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::transactional")," instead of the removed\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::transactional_deps"),"."),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Never")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Empty"),".")),(0,r.kt)("p",null,"Integration tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::ReadonlyStorage")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::Storage"),", which now contains all backend storage methods."),(0,r.kt)("li",{parentName:"ul"},"Storage getters (and iterators) now return a result of\n",(0,r.kt)("inlineCode",{parentName:"li"},"(Option<Vec<u8>>, u64)"),", where the first component is the element and the second one is the gas cost. Thus in a few\nplaces ",(0,r.kt)("inlineCode",{parentName:"li"},".0")," must be added to access the element.")),(0,r.kt)("h2",{id:"072---08"},"0.7.2 -> 0.8"),(0,r.kt)("h3",{id:"update-wasm-code"},"Update wasm code"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," dependencies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Update to ",(0,r.kt)("inlineCode",{parentName:"li"},'schemars = "0.7"')),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm = "0.7"')," with ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm-std = "0.8"')),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm-vm = "0.7"')," with ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm-vm = "0.8"')),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},'cw-storage = "0.2"')," with ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm-storage = "0.8"')),(0,r.kt)("li",{parentName:"ul"},"Remove explicit ",(0,r.kt)("inlineCode",{parentName:"li"},"snafu")," dependency. ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std")," still uses it internally but doesn't expose snafu specifics\nanymore. See more details on errors below.")),(0,r.kt)("p",null,"(Note: until release of ",(0,r.kt)("inlineCode",{parentName:"p"},"0.8"),", you need to use git references for all\n",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm_*")," packages)"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},'"cosmwasm/backtraces"')," with ",(0,r.kt)("inlineCode",{parentName:"li"},'"cosmwasm-std/backtraces"'))),(0,r.kt)("p",null,"Imports:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Replace all ",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm::X::Y")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::Y"),", except for mock"),(0,r.kt)("li",{parentName:"ul"},"Replace all ",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm::mock::Y")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::testing::Y"),". This should only be used in test code."),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"cw_storage:X")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::X")),(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Response")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::HandleResponse")," and\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::InitResponse")," (different type for each call)")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,r.kt)("p",null,"This has been re-written, but is generic boilerplate and should be (almost) the same in all contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"copy the new version from\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CosmWasm/cosmwasm/blob/master/contracts/queue/src/lib.rs"},(0,r.kt)("inlineCode",{parentName:"a"},"contracts/queue"))),(0,r.kt)("li",{parentName:"ul"},"Add ",(0,r.kt)("inlineCode",{parentName:"li"},"pub mod XYZ")," directives for any modules you use besides ",(0,r.kt)("inlineCode",{parentName:"li"},"contract"))),(0,r.kt)("p",null,"Contract Code:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add query to extern:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Before: ",(0,r.kt)("inlineCode",{parentName:"li"},"my_func<S: Storage, A: Api>(deps: &Extern<S, A>, ...")),(0,r.kt)("li",{parentName:"ul"},"After: ",(0,r.kt)("inlineCode",{parentName:"li"},"my_func<S: Storage, A: Api, Q: Querier>(deps: &Extern<S, A, Q>, ...")),(0,r.kt)("li",{parentName:"ul"},"Remember to add ",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::Querier;")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"query")," now returns ",(0,r.kt)("inlineCode",{parentName:"p"},"StdResult<Binary>")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<Vec<u8>>")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"You can also replace ",(0,r.kt)("inlineCode",{parentName:"li"},"to_vec(...)")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"to_binary(...)")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"No ",(0,r.kt)("inlineCode",{parentName:"p"},".context(...)")," is required after ",(0,r.kt)("inlineCode",{parentName:"p"},"from_slice")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"to_vec"),", they return proper ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::Error")," variants on\nerrors.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"env.message.signer")," becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"env.message.sender"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If you used ",(0,r.kt)("inlineCode",{parentName:"p"},"env.contract.balance"),", you must now use the querier. The following code block should work:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// before (in env)\nlet foo = env.contract.balance;\n\n// after (query my balance)\nlet contract_addr = deps.api.human_address(&env.contract.address)?;\nlet balance = deps.querier.query_all_balances(&contract_addr)?;\nlet foo = balance.amount;\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update the ",(0,r.kt)("inlineCode",{parentName:"p"},"CosmosMsg")," enums used:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Send{}")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Bank(BankMsg::Send{})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Opaque{ data }")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Native{ msg }")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Contract")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Wasm(WasmMsg::Execute{})")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Complete overhaul of ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm::Error")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::StdError"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Auto generated snafu error constructor structs like ",(0,r.kt)("inlineCode",{parentName:"li"},"NotFound"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"ParseErr"),"/\u2026 have been privatized in favour of error\ngeneration helpers like\n",(0,r.kt)("inlineCode",{parentName:"li"},"not_found"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"parse_err"),"/\u2026"),(0,r.kt)("li",{parentName:"ul"},"All error generator functions now return errors instead of results, such that e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"return unauthorized();"),"\nbecomes ",(0,r.kt)("inlineCode",{parentName:"li"},"return Err(unauthorized());")),(0,r.kt)("li",{parentName:"ul"},"Error cases don't contain ",(0,r.kt)("inlineCode",{parentName:"li"},"source")," fields anymore. Instead source errors are converted to standard types\nlike ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),". For this reason, both\n",(0,r.kt)("inlineCode",{parentName:"li"},"snafu::ResultExt")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"snafu::OptionExt")," cannot be used anymore. An error wrapper now looks\nlike ",(0,r.kt)("inlineCode",{parentName:"li"},".map_err(invalid_base64)")," and an ",(0,r.kt)("inlineCode",{parentName:"li"},"Option::None")," to error mapping looks\nlike ",(0,r.kt)("inlineCode",{parentName:"li"},'.ok_or_else(|| not_found("State"))'),"."),(0,r.kt)("li",{parentName:"ul"},"Backtraces became optional. Use ",(0,r.kt)("inlineCode",{parentName:"li"},"RUST_BACKTRACE=1")," to enable them for unit tests."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Utf8Err"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"Utf8StringErr")," merged into ",(0,r.kt)("inlineCode",{parentName:"li"},"StdError::InvalidUtf8")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Base64Err")," renamed into ",(0,r.kt)("inlineCode",{parentName:"li"},"StdError::InvalidBase64")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ContractErr"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"DynContractErr")," merged into ",(0,r.kt)("inlineCode",{parentName:"li"},"StdError::GenericErr"),", thus both\n",(0,r.kt)("inlineCode",{parentName:"li"},"contract_err")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"dyn_contract_err")," must be replaced with ",(0,r.kt)("inlineCode",{parentName:"li"},"generic_err"),"."),(0,r.kt)("li",{parentName:"ul"},"The unused ",(0,r.kt)("inlineCode",{parentName:"li"},"ValidationErr")," was removed")))),(0,r.kt)("p",null,"At this point ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo wasm")," should pass."),(0,r.kt)("h3",{id:"update-test-code"},"Update test code"),(0,r.kt)("p",null,"Both:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Update all imports from ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm::mock::*")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::testing::*"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"from_binary")," not ",(0,r.kt)("inlineCode",{parentName:"p"},"from_slice")," on all query responses (update imports)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"from_slice(res.as_slice())")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"from_binary(&res)")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},'coin("123", "FOO")')," with ",(0,r.kt)("inlineCode",{parentName:"p"},'coins(123, "FOO")'),". We renamed it to coins to be more explicit that it\nreturns ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<Coin>"),", and now accept a ",(0,r.kt)("inlineCode",{parentName:"p"},"u128")," as the first argument for better type-safety. ",(0,r.kt)("inlineCode",{parentName:"p"},"coin")," is now an alias to\n",(0,r.kt)("inlineCode",{parentName:"p"},"Coin::new")," and returns one ",(0,r.kt)("inlineCode",{parentName:"p"},"Coin"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Remove the 4th argument (contract balance) from all calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_env"),", this is no longer stored in the environment.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," was renamed to ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_dependencies"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_dependencies")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"mock_instance")," take a 2nd argument to set the contract balance (visible for the querier). If you need to set more\nbalances, use ",(0,r.kt)("inlineCode",{parentName:"p"},"mock_XX_with_balances"),". The follow code block explains:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// before: balance as last arg in mock_env\nlet mut deps = dependencies(20);\nlet env = mock_env(&deps.api, "creator", &coins(15, "earth"), &coins(1015, "earth"));\n\n// after: balance as last arg in mock_dependencies\nlet mut deps = mock_dependencies(20, &coins(1015, "earth"));\nlet env = mock_env(&deps.api, "creator", &coins(15, "earth"));\n')))),(0,r.kt)("p",null,"Unit Tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Replace ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"mock_dependencies"))),(0,r.kt)("p",null,"Integration Tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We no longer check errors as strings but have rich types:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Before:\n",(0,r.kt)("inlineCode",{parentName:"li"},'match err { ContractResult::Err(msg) => assert_eq!(msg, "Unauthorized"), ... }')),(0,r.kt)("li",{parentName:"ul"},"After: ",(0,r.kt)("inlineCode",{parentName:"li"},"match err { Err(StdError::Unauthorized{ .. }) => {}, ... }")))),(0,r.kt)("li",{parentName:"ul"},"Remove all imports / use of ",(0,r.kt)("inlineCode",{parentName:"li"},"ContractResult")),(0,r.kt)("li",{parentName:"ul"},"You must specify ",(0,r.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Native")," type when calling\n",(0,r.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::testing::{handle, init}"),". You will want to\n",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::{HandleResult, InitResult}")," or\n",(0,r.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::{HandleResponse, InitResponse}"),". If you don't use custom native types, simply update calls as\nfollows:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let res = init(...)")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"let res: InitResult = init(...)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let res = init(...).unwrap()")," =>\n",(0,r.kt)("inlineCode",{parentName:"li"},"let res: InitResponse = init(...).unwrap()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let res = handle(...)")," => ",(0,r.kt)("inlineCode",{parentName:"li"},"let res: HandleResult = handle(...)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let res = handle(...).unwrap()")," =>\n",(0,r.kt)("inlineCode",{parentName:"li"},"let res: HandleResponse = handle(...).unwrap()"))))),(0,r.kt)("h3",{id:"update-schema-code"},"Update schema code"),(0,r.kt)("p",null,"All helper functions have been moved into a new ",(0,r.kt)("inlineCode",{parentName:"p"},"cosmwasm-schema")," package."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add ",(0,r.kt)("inlineCode",{parentName:"li"},'cosmwasm-schema = "0.8"')," to ",(0,r.kt)("inlineCode",{parentName:"li"},"[dev-dependencies]")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"Cargo.toml")),(0,r.kt)("li",{parentName:"ul"},"Remove ",(0,r.kt)("inlineCode",{parentName:"li"},"serde_json")," ",(0,r.kt)("inlineCode",{parentName:"li"},"[dev-dependency]")," if there, as cosmwasm-schema will handle JSON output internally."),(0,r.kt)("li",{parentName:"ul"},"Update ",(0,r.kt)("inlineCode",{parentName:"li"},"examples/schema.rs")," to look\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/CosmWasm/cosmwasm/blob/master/contracts/queue/examples/schema.rs"},"more like queue"),", but replacing\nall the imports and type names with those you currently have."),(0,r.kt)("li",{parentName:"ul"},"Regenerate schemas with ",(0,r.kt)("inlineCode",{parentName:"li"},"cargo schema"))),(0,r.kt)("h3",{id:"polishing"},"Polishing"),(0,r.kt)("p",null,"After so many changes, remember to let the linters do their jobs."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo fmt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cargo clippy"))))}m.isMDXComponent=!0}}]);