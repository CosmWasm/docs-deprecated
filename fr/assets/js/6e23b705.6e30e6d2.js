"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2932],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(c,".").concat(d)]||u[d]||p[d]||i;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},540:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var a=n(3117),r=(n(7294),n(3905));const i={sidebar_position:1},o="Anatomie d'un contrat intelligent",s={unversionedId:"develop-smart-contract/intro",id:"develop-smart-contract/intro",title:"Anatomie d'un contrat intelligent",description:"Un contrat intelligent peut \xeatre consid\xe9r\xe9 comme une instance d'un objet singleton dont l'\xe9tat interne est conserv\xe9 sur la blockchain . Users can trigger state changes or query the contract state through sending the contract JSON formatted execute function calls or query messages.",source:"@site/i18n/fr/docusaurus-plugin-content-docs-dev-academy/current/develop-smart-contract/01-intro.md",sourceDirName:"develop-smart-contract",slug:"/develop-smart-contract/intro",permalink:"/fr/dev-academy/develop-smart-contract/intro",draft:!1,editUrl:"https://crowdin.com/project/cosmwasm-docs/fr",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"devAcademy",previous:{title:"D\xe9fi",permalink:"/fr/dev-academy/smart-contract-interaction/challenge"},next:{title:"Developing a Smart Contract",permalink:"/fr/dev-academy/develop-smart-contract/develop"}},c={},l=[{value:"Commencez par un mod\xe8le",id:"commencez-par-un-mod\xe8le",level:2},{value:"Project Overview",id:"project-overview",level:2},{value:"Contract State",id:"contract-state",level:2},{value:"InstantiateMsg",id:"instantiatemsg",level:2},{value:"Message Definition",id:"message-definition",level:3},{value:"Instantiation Logic",id:"instantiation-logic",level:3},{value:"ExecuteMsg",id:"executemsg",level:2},{value:"Message Definition",id:"message-definition-1",level:3},{value:"Schemas",id:"schemas",level:2},{value:"Schema Generation",id:"schema-generation",level:3}],m={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"anatomie-dun-contrat-intelligent"},"Anatomie d'un contrat intelligent"),(0,r.kt)("p",null,"Un contrat intelligent peut \xeatre consid\xe9r\xe9 comme une instance d'un objet singleton dont l'\xe9tat interne est conserv\xe9 sur la blockchain . Users can trigger state changes or query the contract state through sending the contract JSON formatted execute function calls or query messages."),(0,r.kt)("p",null,"Developing a smart contract mainly revolves around defining the following three functions that constitute the interface of a smart contract:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"instantiate()"),": serves as the constructor during contract instantiation and provides the initial state"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execute()"),": est appel\xe9 lorsqu'un utilisateur veut invoquer une m\xe9thode sur le smart contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"query()"),": gets called when a user wants to request current-state related data from the smart contract")),(0,r.kt)("p",null,"This section will cover how different instantiate, execute and query messages are defined, along with the implementation of smart contract functions that process those messages."),(0,r.kt)("h2",{id:"commencez-par-un-mod\xe8le"},"Commencez par un mod\xe8le"),(0,r.kt)("p",null,"In your workspace directory, you'll want to use ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo-generate")," to quick-start a smart contract project with the recommended folder structure and build options:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"# install cargo-generate\ncargo install cargo-generate --features vendored-openssl\ncargo generate --git https://github.com/CosmWasm/cosmwasm-template.git --name my-first-contract\ncd my-first-contract\n")),(0,r.kt)("p",null,"The template helps you get started by providing the basic boilerplate and structure for a smart contract. At this point, you may start examining the project contents with your favorite IDE."),(0,r.kt)("h2",{id:"project-overview"},"Project Overview"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"/src")," directory contains the smart contract source code in separate files."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The file ",(0,r.kt)("inlineCode",{parentName:"li"},"src/contract.rs")," contains the main smart contract logic and is where the functions instantiate(), execute() and query() are implemented."),(0,r.kt)("li",{parentName:"ul"},"The file ",(0,r.kt)("inlineCode",{parentName:"li"},"src/state.rs")," defines how the smart contract state data is represented and the way it will be stored."),(0,r.kt)("li",{parentName:"ul"},"The file ",(0,r.kt)("inlineCode",{parentName:"li"},"src/msg.rs")," is where different types of messages and responses the smart contract can receive and return are defined."),(0,r.kt)("li",{parentName:"ul"},"The file ",(0,r.kt)("inlineCode",{parentName:"li"},"src/error.rs")," defines the error types that can be returned by the smart contract."),(0,r.kt)("li",{parentName:"ul"},"The file ",(0,r.kt)("inlineCode",{parentName:"li"},"src/lib.rs")," is where all the previous modules are exposed and made accessible.")),(0,r.kt)("h2",{id:"contract-state"},"Contract State"),(0,r.kt)("p",null,"Let us start by examining the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/state.rs"),"."),(0,r.kt)("p",null,"The starting template has the following basic state:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a singleton struct ",(0,r.kt)("inlineCode",{parentName:"li"},"State")," containing:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a 32-bit integer ",(0,r.kt)("inlineCode",{parentName:"li"},"count")),(0,r.kt)("li",{parentName:"ul"},"an address ",(0,r.kt)("inlineCode",{parentName:"li"},"owner"))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// src/state.rs\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Addr;\nuse cw_storage_plus::Item;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n    pub count: i32,\n    pub owner: Addr,\n}\n")),(0,r.kt)("p",null,"Smart contracts have the ability to keep persistent state through native LevelDB, a byte-array-based key-value store. As such, any data you wish to persist should be assigned a unique key with which the data can be indexed and later retrieved."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/state.rs\npub const STATE : Item<State> = Item::new("state") ;\n')),(0,r.kt)("p",null,"In the example above, the key ",(0,r.kt)("inlineCode",{parentName:"p"},'"state"')," is used as a prefix."),(0,r.kt)("p",null,"Data can only be persisted as a raw byte array, so any notion of structure or data-type must be expressed as a pair of serializing and deserializing functions. For instance, objects must be stored as bytes, so you must supply both the function that encodes the object into bytes to save it on the blockchain, and the function that decodes the bytes back into the data-types that your contract logic can understand. The choice of byte representation is up to you, so long as it provides a clean, bi-directional mapping."),(0,r.kt)("p",null,"Fortunately, the CosmWasm team have provided utility crates such as ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/tree/main/packages/storage"},"cosmwasm_storage"),', which provides convenient high-level abstractions for data containers such as a "singleton" and "bucket", which automatically provide serialization and deserialization for commonly-used types such as structs and Rust numbers.'),(0,r.kt)("p",null,"Notice how the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," struct holds both ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"owner"),". In addition, the ",(0,r.kt)("inlineCode",{parentName:"p"},"derive")," attribute is applied to auto-implement some useful traits:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Serialize"),": provides serialization"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Deserialize"),": provides deserialization"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Clone"),": makes our struct copyable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Debug"),": enables our struct to be printed to string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PartialEq"),": gives us equality comparison"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"JsonSchema"),": auto-generates a JSON schema for us")),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr")," represents a human-readable Bech32 address with a ",(0,r.kt)("inlineCode",{parentName:"p"},"wasm")," prefix."),(0,r.kt)("h2",{id:"instantiatemsg"},"InstantiateMsg"),(0,r.kt)("p",null,"Defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," is received when an address tries to instantiate a contract on the blockchain through a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgInstantiateContract")," message. This message provides the contract with initial configuration and state."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"On CosmWasm, the upload of a contract's code and the instantiation of a contract are regarded as\nseparate events, unlike on Ethereum. This is to allow a small set of vetted contract archetypes to exist as\nmultiple instances sharing the same base code but be configured with different parameters (imagine one canonical ERC20, and multiple tokens that use its code).")),(0,r.kt)("h3",{id:"message-definition"},"Message Definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// src/msg.rs\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n  pub count: i32,\n}\n\n")),(0,r.kt)("p",null,"For our template contract, we will expect a contract creator to supply the initial state in a JSON formatted message as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "count": 100\n}\n')),(0,r.kt)("p",null,"This message arrives embedded in the received ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgInstantiateContract")," message during instantiation."),(0,r.kt)("h3",{id:"instantiation-logic"},"Instantiation Logic"),(0,r.kt)("p",null,"Defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/contract.rs"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiate()")," function is the first entry-point, or where the contract processes a received ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgInstantiateContract")," message. The instantiation data is extracted from the message and is used to set out the initial state, as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n  deps: DepsMut,\n  _env: Env,\n  info: MessageInfo,\n  msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n  //An overview of function parameters:\n\n  //"deps" allows us to perform storage related actions, validate addresses and query other smart contracts\n  //"_env" is mainly used to access details about the current state of the blockchain (i.e., block height, time, chain id) \n  //"info" provides access to the message metadata (i.e., sender address, the amount and type of funds)\n  //"msg" is the MsgInstantiateContract payload, which comprises the data received from the contract creator\n  //in JSON format that conforms to the InstantiateMsg struct\n\n  //Introduce a new variable named `state` of type `State`\n  let state = State {\n    //the value for count in the received message is assigned to the variable `count` of the `State` struct\n    count: msg.count,\n    //the sender address of the MsgInstantiateContract is assigned to the variable `owner` of the `State` struct\n    owner: info.sender.clone(),\n  };\n  //Store the contract name and version\n  set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n  //Store the initial state of the contract\n  STATE.save(deps.storage, &state)?;\n\n  //Form and return an Ok(Response)\n  //The attributes will be included in the JSON formatted response message\n  Ok(Response::new()\n    .add_attribute("method", "instantiate")\n    .add_attribute("owner", info.sender)\n    .add_attribute("count", msg.count.to_string()))\n}\n')),(0,r.kt)("h2",{id:"executemsg"},"ExecuteMsg"),(0,r.kt)("p",null,"Defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),", an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," is received when an address tries to invoke one of the smart contract functions through a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," message. Unlike the ",(0,r.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),", which was a single struct; the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," is an enumerator, which essentially holds a list of possible execute message structs with different names and attributes to account for the different types of functions that a smart contract can expose to a user. The ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()")," function demultiplexes these different types of messages and forwards them to the appropriate message handler logic."),(0,r.kt)("h3",{id:"message-definition-1"},"Message Definition"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," enum contains the different types of execute messages that our contract can understand."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/msg.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n  Increment {},\n  Reset { count: i32 },\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"The line ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},'#[serde(rename_all = "snake_case")]')," performs a snake_case conversion (lowercase initials with an underscore between words) on the field names before serialization and deserialization. So, we'll have ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"increment")," and ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"reset")," instead of ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"Increment")," and ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"Reset")," when serializing and deserializing across JSON formatted messages. :::"),(0,r.kt)("p",{parentName:"admonition"},"At this point, our template contract can accept the following two types of execute messages in JSON format, embedded in a ",(0,r.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," message:"),(0,r.kt)("h4",{parentName:"admonition",id:"increment"},"Increment"),(0,r.kt)("p",{parentName:"admonition"},"Any address can utilize the Increment function to increment the current count by 1."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "increment": {}\n}\n')),(0,r.kt)("h4",{parentName:"admonition",id:"reset"},"Reset"),(0,r.kt)("p",{parentName:"admonition"},"The owner of the contract can reset the count to an arbitrary number. The check regarding whether a user is the contract owner is a part of the execution logic."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "reset": {\n    "count": 5\n  }\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"execution-logic"},"Execution Logic"),(0,r.kt)("p",{parentName:"admonition"},"Defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/contract.rs"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()")," function uses Rust's pattern matching to route the received ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," to the appropriate handling logic, by either routing to the function ",(0,r.kt)("inlineCode",{parentName:"p"},"try_increment()")," or  ",(0,r.kt)("inlineCode",{parentName:"p"},"try_reset()")," depending on the type of message received."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn execute(\n  deps : DepsMut,\n  _env : Env,\n  info : MessageInfo,\n  msg : ExecuteMsg,\n) -> Result<Response, ContractError> {\n  match msg {\n    ExecuteMsg::Increment {} => try_increment(deps),\n    ExecuteMsg::Reset { count } => try_reset(deps, info, count),\n  }\n}\n')),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn try_increment(deps : DepsMut) -> Result<Response, ContractError> {\n  STATE.update(deps.storage, |mut state| -> Result<_, ContractError> {\n    state.count = 1 ;\n    Ok(state)\n  })? ;\n\n  Ok(Response::new().add_attribute("method", "try_increment"))\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"It is quite straightforward to follow the logic of ",(0,r.kt)("inlineCode",{parentName:"p"},"try_increment()"),". We acquire a mutable reference to the storage to update the item located at key ",(0,r.kt)("inlineCode",{parentName:"p"},'"state"'),", made accessible through the ",(0,r.kt)("inlineCode",{parentName:"p"},"STATE")," convenience function defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"src/state.rs"),". We then update the present state's count by returning an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," result with the new state. Finally, we terminate the contract's execution with an acknowledgement of success by returning an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," result with the default ",(0,r.kt)("inlineCode",{parentName:"p"},"Response"),"."),(0,r.kt)("p",{parentName:"admonition"},"In this example, the default ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," is used for simplicity. However, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Response")," can be manually created to provide the following information:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"messages"),": A list of messages. This is how smart contracts execute other smart contract functions or use native modules."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attributes"),": A list of key-value pairs to define emitted SDK events that can be subscribed to and parsed by clients."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"events"),": Extra, custom events separate from the main ",(0,r.kt)("inlineCode",{parentName:"li"},"wasm")," one. These will have ",(0,r.kt)("inlineCode",{parentName:"li"},"wasm-")," prepended to the type. These can be used by explorers and applications to report important events or state changes that occurred during the execution."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data"),": additional data that the contract returns to the client.")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/contract.rs\npub fn try_reset(deps : DepsMut, info : MessageInfo, count : i32) -> Result<Response, ContractError> {\n  STATE.update(deps.storage, |mut state| -> Result<_, ContractError> {\n    if info.sender != state.owner {\n      return Err(ContractError::Unauthorized {}) ;\n    } }\n    state.count = count ;\n    Ok(state)\n  })? ;\n  Ok(Response::new().add_attribute("method", "reset"))\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"The logic for try_reset() is very similar to increment \u2014 except this time, we first check that the message sender is permitted to invoke the reset function. Please, observe the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractError::Unauthorized {}")," to return an error if the sender is not the owner of the contract. Custom error messages can be defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/error.rs"),"."),(0,r.kt)("h2",{parentName:"admonition",id:"querymsg"},"QueryMsg"),(0,r.kt)("p",{parentName:"admonition"},"Defined in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg")," is received when an address tries to query information about the current state of the smart contract. Similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecuteMsg"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg")," is an enumerator and holds a list of possible query message structs with different names and attributes in order to cover the different types of query functions a user can invoke. The ",(0,r.kt)("inlineCode",{parentName:"p"},"query()")," function demultiplexes these different types of messages and forwards them to the appropriate message handler logic."),(0,r.kt)("p",{parentName:"admonition"},"In addition to handling how the queries are received, the contract also needs a structured way of outputting query responses. This is accomplished by defining response structs (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"CountResponse"),") in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs"),", so the querying party may know what to expect from the JSON response to be received."),(0,r.kt)("h3",{parentName:"admonition",id:"d\xe9finition-du-message"},"D\xe9finition du message"),(0,r.kt)("p",{parentName:"admonition"},"The template contract only supports one type of ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryMsg")," message, which is ",(0,r.kt)("inlineCode",{parentName:"p"},"GetCount"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/msg.rs\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum QueryMsg {\n  // GetCount returns the current count as a json-encoded number\n  GetCount {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct CountResponse {\n  pub count: i32,\n}\n')),(0,r.kt)("h4",{parentName:"admonition",id:"getcount"},"GetCount"),(0,r.kt)("p",{parentName:"admonition"},"The query message:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "get_count": {}\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"The contract should return a ",(0,r.kt)("inlineCode",{parentName:"p"},"CountResponse")," with the current count in JSON format."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "count": 5\n}\n')),(0,r.kt)("h3",{parentName:"admonition",id:"query-logic"},"Query Logic"),(0,r.kt)("p",{parentName:"admonition"},"The logic for ",(0,r.kt)("inlineCode",{parentName:"p"},"query()")," is similar to that of ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()"),", except the fact that the ",(0,r.kt)("inlineCode",{parentName:"p"},"query()")," function is called without the need of making a transaction by the end-user. Therefore, the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"info")," can be omitted in the query() function signature as there is no message information present to be processed."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// src/contract.rs\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n  match msg {\n    // Match and route the query message to the appropriate handler\n    QueryMsg::GetCount {} => to_binary(&query_count(deps)?),\n    // Return the response in byte-array format\n  }\n}\n\nfn query_count(deps: Deps) -> StdResult<CountResponse> {\n  let state = STATE.load(deps.storage)?;\n  // Load the current contract state\n  Ok(CountResponse { count: state.count })\n  // Form and return a CountResponse\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"The query() function matches the received message with one of the QueryMsg structs defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"/src/msg.rs")," and  routes the received QueryMsg to the appropriate handling logic before returning a specific query response in byte-array format."),(0,r.kt)("h2",{parentName:"admonition",id:"building-the-contract"},"Building the Contract"),(0,r.kt)("p",{parentName:"admonition"},"To build your contract, run the following command."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cargo wasm\n")),(0,r.kt)("p",{parentName:"admonition"},"This will check for any preliminary errors and output a .wasm binary under the folder ",(0,r.kt)("inlineCode",{parentName:"p"},"/target/wasm32/release"),"."),(0,r.kt)("h3",{parentName:"admonition",id:"optimizing-your-build"},"Optimizing your build")),(0,r.kt)("p",null,"You will need to make sure the output WASM binary is as small as possible in order to minimize fees and stay under the size limit for the blockchain. Run the following command in the root directory of your Rust smart contract's project folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'docker run --rm -v "$(pwd)":/code \\\n  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer:0.12.6\n')),(0,r.kt)("p",null,"On Windows, you can run the following command instead from the root of your smart contract's project folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-powershell"},'docker run --rm -v ${pwd}:/code `\n --mount type=volume,source="$("$(Split-Path -Path $pwd -Leaf)")_cache",target=/code/target `\n --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry `\n cosmwasm/rust-optimizer:0.12.6\n')),(0,r.kt)("p",null,"This will result in an optimized .wasm binary under the folder ",(0,r.kt)("inlineCode",{parentName:"p"},"/artifacts")," in your project directory."),(0,r.kt)("admonition",{title:"optional",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You may add the optimization command above in ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," for quick access."),(0,r.kt)("p",{parentName:"admonition"},"This allows running custom scripts in a similar way to what ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," does in the Node ecosystem."),(0,r.kt)("p",{parentName:"admonition"},"Install ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo-run-script")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cargo install cargo-run-script\n")),(0,r.kt)("p",{parentName:"admonition"},"Add the script in ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[package.metadata.scripts]\noptimize = """docker run --rm -v "$(pwd)":/code \\\n  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer:0.12.6\n"""\n')),(0,r.kt)("p",{parentName:"admonition"},"Run the command:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cargo run-script optimize\n"))),(0,r.kt)("h2",{id:"schemas"},"Schemas"),(0,r.kt)("p",null,"The file ",(0,r.kt)("inlineCode",{parentName:"p"},"/examples/schema.rs")," contains the configuration for JSON-schema auto-generation.  With the help of schema files, the different data structures that form the smart contract's interface can be represented in JSON format."),(0,r.kt)("h3",{id:"schema-generation"},"Schema Generation"),(0,r.kt)("p",null,"The configuration file should include an entry for each data structure we need a schema for."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// examples/schema.rs\n\nuse std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse my_first_contract::msg::{CountResponse, ExecuteMsg, InstantiateMsg, QueryMsg};\nuse my_first_contract::state::State;\n\nfn main() {\n  let mut out_dir = current_dir().unwrap();\n  out_dir.push("schema");\n  create_dir_all(&out_dir).unwrap();\n  remove_schemas(&out_dir).unwrap();\n\n  export_schema(&schema_for!(InstantiateMsg), &out_dir);\n  export_schema(&schema_for!(ExecuteMsg), &out_dir);\n  export_schema(&schema_for!(QueryMsg), &out_dir);\n  export_schema(&schema_for!(State), &out_dir);\n  export_schema(&schema_for!(CountResponse), &out_dir);\n}\n')),(0,r.kt)("p",null,"You can then build the schemas with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cargo schema\n")),(0,r.kt)("p",null,"The newly generated schemas should be accessible in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/schema")," directory. The following is an example of ",(0,r.kt)("inlineCode",{parentName:"p"},"/schema/query_msg.json"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "title": "QueryMsg",\n  "anyOf": [\n    {\n      "type": "object",\n      "required": [\n        "get_count"\n      ],\n      "properties": {\n        "get_count": {\n          "type": "object"\n        }\n      },\n      "additionalProperties": false\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"You can use an online tool such as ",(0,r.kt)("a",{parentName:"p",href:"https://www.jsonschemavalidator.net/"},"JSON Schema Validator")," to test ",(0,r.kt)("a",{parentName:"p",href:"/dev-academy/develop-smart-contract/intro#getcount"},"your input")," against the generated JSON schema."))}p.isMDXComponent=!0}}]);