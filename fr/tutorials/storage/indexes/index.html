<!doctype html>
<html class="docs-version-current" lang="fr" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="search" type="application/opensearchdescription+xml" title="CosmWasm Documentation" href="/fr/opensearch.xml"><title data-react-helmet="true">Indexes | CosmWasm Documentation</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://docs.cosmwasm.com/fr/tutorials/storage/indexes"><meta data-react-helmet="true" name="docsearch:language" content="fr"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-tutorials-current"><meta data-react-helmet="true" property="og:title" content="Indexes | CosmWasm Documentation"><meta data-react-helmet="true" name="description" content="Indexes are key structures that enable iteration over primary keys using value information. Here is an example for"><meta data-react-helmet="true" property="og:description" content="Indexes are key structures that enable iteration over primary keys using value information. Here is an example for"><link data-react-helmet="true" rel="icon" href="/fr/img/favicon.svg"><link data-react-helmet="true" rel="canonical" href="https://docs.cosmwasm.com/fr/tutorials/storage/indexes"><link data-react-helmet="true" rel="alternate" href="https://docs.cosmwasm.com/tutorials/storage/indexes" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.cosmwasm.com/fr/tutorials/storage/indexes" hreflang="fr"><link data-react-helmet="true" rel="alternate" href="https://docs.cosmwasm.com/tutorials/storage/indexes" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/fr/assets/css/styles.293cb3ed.css">
<link rel="preload" href="/fr/assets/js/runtime~main.573066c5.js" as="script">
<link rel="preload" href="/fr/assets/js/main.23c82edf.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_aKYr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://docs.cosmwasm.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><div class="navbar__logo"><img src="/fr/img/logo.svg" alt="CosmWasm" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/fr/img/logo_dark.svg" alt="CosmWasm" class="themedImage_W2Cr themedImage--dark_oUvU"></div></a><a class="navbar__item navbar__link" href="/fr/docs/1.0/">Docs</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link">Learn</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/fr/dev-academy/intro">Dev Academy</a></li><li><a class="dropdown__link" href="/fr/tutorials/hijack-escrow/intro">Tutorials</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link">dApps</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/fr/cw-plus/0.9.0/overview">cw-plus</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link" docspluginid="ecosystem">Ecosystem</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/fr/ecosystem/overview">Overview</a></li><li><a class="dropdown__link" href="/fr/ecosystem/jobs">Jobs</a></li><li><a class="dropdown__link" href="/fr/ecosystem/testnets/build-requirements">Testnets</a></li><li><a class="dropdown__link" href="/fr/ecosystem/hall-of-fame">Hall of Fame</a></li><li><a class="dropdown__link" href="/fr/ecosystem/media/assets">Media</a></li></ul></div></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link"><span><svg viewBox="0 0 20 20" width="20" height="20" aria-hidden="true" class="iconLanguage_dNtB"><path fill="currentColor" d="M19.753 10.909c-.624-1.707-2.366-2.726-4.661-2.726-.09 0-.176.002-.262.006l-.016-2.063 3.525-.607c.115-.019.133-.119.109-.231-.023-.111-.167-.883-.188-.976-.027-.131-.102-.127-.207-.109-.104.018-3.25.461-3.25.461l-.013-2.078c-.001-.125-.069-.158-.194-.156l-1.025.016c-.105.002-.164.049-.162.148l.033 2.307s-3.061.527-3.144.543c-.084.014-.17.053-.151.143.019.09.19 1.094.208 1.172.018.08.072.129.188.107l2.924-.504.035 2.018c-1.077.281-1.801.824-2.256 1.303-.768.807-1.207 1.887-1.207 2.963 0 1.586.971 2.529 2.328 2.695 3.162.387 5.119-3.06 5.769-4.715 1.097 1.506.256 4.354-2.094 5.98-.043.029-.098.129-.033.207l.619.756c.08.096.206.059.256.023 2.51-1.73 3.661-4.515 2.869-6.683zm-7.386 3.188c-.966-.121-.944-.914-.944-1.453 0-.773.327-1.58.876-2.156a3.21 3.21 0 011.229-.799l.082 4.277a2.773 2.773 0 01-1.243.131zm2.427-.553l.046-4.109c.084-.004.166-.01.252-.01.773 0 1.494.145 1.885.361.391.217-1.023 2.713-2.183 3.758zm-8.95-7.668a.196.196 0 00-.196-.145h-1.95a.194.194 0 00-.194.144L.008 16.916c-.017.051-.011.076.062.076h1.733c.075 0 .099-.023.114-.072l1.008-3.318h3.496l1.008 3.318c.016.049.039.072.113.072h1.734c.072 0 .078-.025.062-.076-.014-.05-3.083-9.741-3.494-11.04zm-2.618 6.318l1.447-5.25 1.447 5.25H3.226z"></path></svg><span>FranÃ§ais</span></span></a><ul class="dropdown__menu"><li><a href="/tutorials/storage/indexes" target="_self" rel="noopener noreferrer" class="dropdown__link">English</a></li><li><a href="/fr/tutorials/storage/indexes" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active">FranÃ§ais</a></li></ul></div><div class="toggle_Pssr toggle_TdHA toggleChecked_cnQY toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" checked="" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y sidebarWithHideableNavbar_FoYL"><a href="https://docs.cosmwasm.com/" target="_blank" rel="noopener noreferrer" tabindex="-1" class="sidebarLogo_FJUI"><img src="/fr/img/logo.svg" alt="CosmWasm" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/fr/img/logo_dark.svg" alt="CosmWasm" class="themedImage_W2Cr themedImage--dark_oUvU"></a><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/fr/tutorials/hijack-escrow/intro">Hijack Escrow</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/fr/tutorials/simple-option/intro">Simple Option</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/fr/tutorials/governance">Smart Contracts Over Governance</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/fr/tutorials/name-service/intro">Name Service</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_VCh3" aria-current="page" href="/fr/tutorials/storage/key-value-store">Storage</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/fr/tutorials/storage/key-value-store">How CW Key Value Storage Works?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/fr/tutorials/storage/indexes">Indexes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/fr/tutorials/storage/state-modeling">Advanced State Modeling</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/fr/tutorials/frontend-dapp/intro">Frontend dApp</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/fr/tutorials/videos-workshops">Videos and Workshops</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_cwdi"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_xORG"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Indexes</h1><p>Indexes are key structures that enable iteration over primary keys using value information. Here is an example for
understanding them.</p><p>Let&#x27;s assume a model: there are multiple tokens in the system, each token has a unique owner. An owner must be related to
a token. Tokens must be queryable by owner.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">struct Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub owner: Addr,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub ticker: String</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Tokens can be identified by an auto incremented key, and this integer will be used as primary key. This will make each
token unique.</p><p><code>(TokenPK) -&gt; Token</code></p><p>Here is the fun part, owner index:
<code>(owner, TokenPK) -&gt; Token</code></p><p>TokenPK points to a Token data, and <code>owner:TokenPK</code> key points to <code>Token</code>. With two database hits, Token data is
accessible. Now to retrieve all the tokens an owner manages, we run prefix range like we have shown above.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub const TOKENS: Map&lt;U8Key, Token&gt; = Map::new(&quot;tokens&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// (owner Address, Token PK) -&gt; u8 key</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub const OWNER_INDEX: Map&lt;(&amp;Addr, U8Key), &amp;[u8]&gt; = Map::new(&quot;owner_tokenpk&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now tokens are easily accessible by <strong>owner</strong> information. On every state change to <code>TOKENS</code>,
<code>owner</code> must be modified accordingly.</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="storage-plus-indexing">storage-plus indexing<a class="hash-link" href="#storage-plus-indexing" title="Direct link to heading">â€‹</a></h2><p>The solution above will work but is not optimal. Too much code complexity and manual work. This is
where <a href="https://github.com/CosmWasm/cw-plus/blob/main/packages/storage-plus/src/indexed_map.rs" target="_blank" rel="noopener noreferrer">storage-plus/IndexedMap</a>
comes into play. <code>IndexedMap</code> is a storage handler that indexes internally. Two types of indexes
are available: <a href="#unique-indexes">Unique Indexes</a> and <a href="#multi-indexes">Multi Indexes</a></p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="unique-indexes">Unique Indexes<a class="hash-link" href="#unique-indexes" title="Direct link to heading">â€‹</a></h3><p>Uniqueness of a data field in a database is quite a common need.
<a href="https://github.com/CosmWasm/cw-plus/blob/v0.7.0/packages/storage-plus/src/indexes.rs" target="_blank" rel="noopener noreferrer">UniqueIndex</a> is an indexing
helper for achieving this functionality.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub owner: Addr,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub ticker: String,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub identifier: u8, // &lt;---- unique value</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// TokenIndexes structs keeps a list of indexers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // token.identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub identifier: UniqueIndex&lt;&#x27;a, U8Key, Token&gt;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// IndexList is just boilerplate code for fetching a struct&#x27;s indexes</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">impl&lt;&#x27;a&gt; IndexList&lt;Token&gt; for TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  fn get_indexes(&amp;&#x27;_ self) -&gt; Box&lt;dyn Iterator&lt;Item=&amp;&#x27;_ dyn Index&lt;Token&gt;&gt; + &#x27;_&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let v: Vec&lt;&amp;dyn Index&lt;Token&gt;&gt; = vec![&amp;self.identifier];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Box::new(v.into_iter())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// tokens() is the storage access function.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn tokens&lt;&#x27;a&gt;() -&gt; IndexedMap&lt;&#x27;a, &amp;&#x27;a [u8], Token, TokenIndexes&lt;&#x27;a&gt;&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let indexes = TokenIndexes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    identifier: UniqueIndex::new(|d| U8Key::new(d.identifier), &quot;token_identifier&quot;),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  IndexedMap::new(TOKEN_NAMESPACE, indexes)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Let&#x27;s go over the code step by step:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub owner: Addr,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub ticker: String,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub identifier: u8, // &lt;---- unique value</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Token has a few values and <code>identifier</code> is a unique value the token has.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// TokenIndexes structs keeps a list of indexers</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // token.identifier</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub identifier: UniqueIndex&lt;&#x27;a, U8Key, Token&gt;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>TokenIndexes</code> is a struct for defining indexes of <code>Token</code> struct.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">impl&lt;&#x27;a&gt; IndexList&lt;Token&gt; for TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  fn get_indexes(&amp;&#x27;_ self) -&gt; Box&lt;dyn Iterator&lt;Item=&amp;&#x27;_ dyn Index&lt;Token&gt;&gt; + &#x27;_&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let v: Vec&lt;&amp;dyn Index&lt;Token&gt;&gt; = vec![&amp;self.identifier];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Box::new(v.into_iter())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>IndexList</code> is an interface for building the indexes.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn tokens&lt;&#x27;a&gt;() -&gt; IndexedMap&lt;&#x27;a, &amp;&#x27;a [u8], Token, TokenIndexes&lt;&#x27;a&gt;&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let indexes = TokenIndexes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    identifier: UniqueIndex::new(|d| U8Key::new(d.identifier), &quot;token_identifier&quot;),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  IndexedMap::new(TOKEN_NAMESPACE, indexes)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>tokens()</code> is storage function used to build <code>IndexedMap</code>.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">    identifier: UniqueIndex::new( | d| U8Key::new(d.identifier), &quot;token_identifier&quot;),</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The above code is an index builder function. It builds composite keys with the given function, and accepts a key to identify the
index bucket.</p><p>Here is some test code:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#[test]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fn test_tokens() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let mut store = MockStorage::new();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let owner1 = Addr::unchecked(&quot;addr1&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let ticker1 = &quot;TOKEN1&quot;.to_string();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token1 = Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: owner1.clone(),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ticker: ticker1,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    identifier: 0,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token_id = increment_tokens(store.borrow_mut()).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  tokens().save(store.borrow_mut(), &amp;U64Key::from(token_id).joined_key(), &amp;token1).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let ticker2 = &quot;TOKEN2&quot;.to_string();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token2 = Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: owner1.clone(),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ticker: ticker2,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    identifier: 0,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token_id = increment_tokens(store.borrow_mut()).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // identifier clashes, must return error</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  tokens().save(store.borrow_mut(), &amp;U64Key::from(token_id).joined_key(), &amp;token1).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The last line will crash with an error:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">called `Result::unwrap()` on an `Err` value: GenericErr { msg: &quot;Violates unique constraint on index&quot; }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">thread &#x27;state::test::test_tokens&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: GenericErr { msg: &quot;Violates unique constraint on index&quot; }&#x27;, src/state.rs:197:90</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">stack backtrace:</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="multi-indexes">Multi Indexes<a class="hash-link" href="#multi-indexes" title="Direct link to heading">â€‹</a></h3><p>Multi indexes are used when the structure is indexed by non-unique values. Here is a case from the <code>cw721</code> smart contract:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // secondary index by owner address</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // the last U64Key is the primary key which is an auto incremented token counter</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub owner: MultiIndex&lt;&#x27;a, (Vec&lt;u8&gt;, Vec&lt;u8&gt;), Token&gt;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// this may become a macro, not important just boilerplate, builds the list of indexes for later use</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">impl&lt;&#x27;a&gt; IndexList&lt;Token&gt; for TokenIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  fn get_indexes(&amp;&#x27;_ self) -&gt; Box&lt;dyn Iterator&lt;Item=&amp;&#x27;_ dyn Index&lt;Token&gt;&gt; + &#x27;_&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let v: Vec&lt;&amp;dyn Index&lt;Token&gt;&gt; = vec![&amp;self.owner];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Box::new(v.into_iter())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const TOKEN_NAMESPACE: &amp;str = &quot;tokens&quot;;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn tokens&lt;&#x27;a&gt;() -&gt; IndexedMap&lt;&#x27;a, &amp;&#x27;a [u8], Token, TokenIndexes&lt;&#x27;a&gt;&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let indexes = TokenIndexes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: MultiIndex::new(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      |d, k| (index_string(d.owner.as_str()), k),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      TOKEN_NAMESPACE,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;tokens__owner&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  IndexedMap::new(TOKEN_NAMESPACE, indexes)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We see that the owner index is a <code>MultiIndex</code>. A multi-index can have repeated values as keys. That&#x27;s why the primary key
is added as the last element of the multi-index key. Like the name implies, this is an index over tokens, by owner. Given
that an owner can have multiple tokens, we need a <code>MultiIndex</code> to be able to list / iterate over all the tokens a given
owner has.</p><p>The important thing here is that the key (and its components, in the case of a combined key) must implement the
PrimaryKey trait. You can see that both the <code>2-tuple (_, _)</code> and <code>Vec&lt;u8&gt;</code> do implement PrimaryKey:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain"> impl&lt;&#x27;a, T: PrimaryKey&lt;&#x27;a&gt; + Prefixer&lt;&#x27;a&gt;, U: PrimaryKey&lt;&#x27;a&gt;&gt; PrimaryKey&lt;&#x27;a&gt; for (T, U) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  type Prefix = T;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  type SubPrefix = ();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  fn key(&amp;self) -&gt; Vec&lt;&amp;[u8]&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let mut keys = self.0.key();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    keys.extend(&amp;self.1.key());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    keys</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain"> pub fn tokens&lt;&#x27;a&gt;() -&gt; IndexedMap&lt;&#x27;a, &amp;&#x27;a str, TokenInfo, TokenIndexes&lt;&#x27;a&gt;&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let indexes = TokenIndexes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: MultiIndex::new(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      |d, k| (Vec::from(d.owner.as_ref()), k),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;tokens&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;tokens__owner&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  IndexedMap::new(&quot;tokens&quot;, indexes)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>During index creation, we must supply an index function per index.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain"> owner: MultiIndex::new(|d, k| (Vec::from(d.owner.as_ref()), k),</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>which is the one that will take the value, and the primary key (always in <code>Vec&lt;u8&gt;</code> form) of the original map, and
create the index key from them. Of course, this mandates that the elements required for the index key are present in the
value (which makes sense).</p><p>Besides the index function, we must also supply the namespace of the pk, and the one for the new index.</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain"> IndexedMap::new(&quot;tokens&quot;, indexes)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here of course, the namespace of the pk must match the one used during index(es) creation. And we pass our
TokenIndexes (as a IndexList-type parameter) as second argument, connecting in this way the underlying Map with the pk,
with the defined indexes.</p><p>IndexedMap (and the other Indexed* types) is just a wrapper / extension around Map, that provides a number of index
functions and namespaces to create indexes over the original Map data. It also implements calling these index functions
during value storage / modification / removal, so that you can forget about it and just use the indexed data.</p><p>Here is a code example on using indexes:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#[test]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fn test_tokens() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let mut store = MockStorage::new();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let owner1 = Addr::unchecked(&quot;addr1&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let ticker1 = &quot;TOKEN1&quot;.to_string();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token1 = Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: owner1.clone(),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ticker: ticker1,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let ticker2 = &quot;TOKEN2&quot;.to_string();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token2 = Token {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    owner: owner1.clone(),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ticker: ticker2,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token_id = increment_tokens(store.borrow_mut()).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  tokens().save(store.borrow_mut(), &amp;U64Key::from(token_id).joined_key(), &amp;token1).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let token_id = increment_tokens(store.borrow_mut()).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  tokens().save(store.borrow_mut(), &amp;U64Key::from(token_id).joined_key(), &amp;token1).unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  // want to load token using owner1 and ticker1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let list: Vec&lt;_&gt; = tokens()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    .idx.owner</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    .prefix(index_string(owner1.as_str()))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    .range(&amp;store, None, None, Order::Ascending)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    .collect::&lt;StdResult&lt;_&gt;&gt;().unwrap();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let (_, t) = &amp;list[0];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  assert_eq!(t, &amp;token1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  assert_eq!(2, list.len());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="composite-multi-indexing">Composite Multi Indexing<a class="hash-link" href="#composite-multi-indexing" title="Direct link to heading">â€‹</a></h3><p>Imagine the following situation:
we have a number of batches, each stored by its (numeric) batch id, that can change
after which they must be automatically promoted. Now imagine that we want to process all the pending batches at any
status from <strong>Pending</strong> to <strong>Promoted</strong>, depending on interactions over them. The batches also have an associated
expiration, given time. Of course, we are only interested in the pending ones that have already expired (so that we can promote
them). So, we can build an index over the batches, with a composite key composed of the batch status, and their
expiration timestamp. Using the composite key, we&#x27;ll be discarding both, the already promoted batches, and the pending
but not yet expired ones.</p><p>So, we build the index, generate the composite key, and iterate over all pending batches that
have an expiration timestamp that is less than the current time.</p><p>Here&#x27;s a code example on how to do this:</p><p>Batch struct:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/// A Batch is a group of members who got voted in together. We need this to</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">/// calculate moving from *Paid, Pending Voter* to *Voter*</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct Batch {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  /// Timestamp (seconds) when all members are no longer pending</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub grace_ends_at: u64,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  /// How many must still pay in their escrow before the batch is early authorized</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub waiting_escrow: u32,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  /// All paid members promoted. We do this once when grace ends or waiting escrow hits 0.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  /// Store this one done so we don&#x27;t loop through that anymore.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub batch_promoted: bool,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  /// List of all members that are part of this batch (look up ESCROWS with these keys)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub members: Vec&lt;Addr&gt;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>IndexedMap</code> definitions:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// We need a secondary index for batches, such that we can look up batches that have</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// not been promoted, ordered by expiration (ascending) from now.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Index: (U8Key/bool: batch_promoted, U64Key: grace_ends_at) -&gt; U64Key: pk</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub struct BatchIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  pub promotion_time: MultiIndex&lt;&#x27;a, (U8Key, U64Key, U64Key), Batch&gt;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">impl&lt;&#x27;a&gt; IndexList&lt;Batch&gt; for BatchIndexes&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  fn get_indexes(&amp;&#x27;_ self) -&gt; Box&lt;dyn Iterator&lt;Item=&amp;&#x27;_ dyn Index&lt;Batch&gt;&gt; + &#x27;_&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    let v: Vec&lt;&amp;dyn Index&lt;Batch&gt;&gt; = vec![&amp;self.promotion_time];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Box::new(v.into_iter())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn batches&lt;&#x27;a&gt;() -&gt; IndexedMap&lt;&#x27;a, U64Key, Batch, BatchIndexes&lt;&#x27;a&gt;&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let indexes = BatchIndexes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    promotion_time: MultiIndex::new(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      |b: &amp;Batch, pk: Vec&lt;u8&gt;| {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let promoted = if b.batch_promoted { 1u8 } else { 0u8 };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        (promoted.into(), b.grace_ends_at.into(), pk.into())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      },</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;batch&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      &quot;batch__promotion&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  IndexedMap::new(&quot;batch&quot;, indexes)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This example is similar to the previous one, above. The only differences are:</p><p>The composite key now has three elements: the batch status, the expiration timestamp, and the batch id (which is the
primary key for the Batch data). We&#x27;re using a U64Key for the batch id / pk. This is just for convenience. We could as
well have used a plain <code>Vec&lt;u8&gt;</code> for it.</p><p>Now, here&#x27;s how to use the indexed data:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let batch_map = batches();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Limit to batches that have not yet been promoted (0), using sub_prefix.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Iterate which have expired at or less than the current time (now), using a bound.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// These are all eligible for timeout-based promotion</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let now = block.time.nanos() / 1_000_000_000;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// as we want to keep the last item (pk) unbounded, we increment time by 1 and use exclusive (below the next tick)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let max_key = (U64Key::from(now + 1), U64Key::from(0)).joined_key();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let bound = Bound::Exclusive(max_key);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let ready = batch_map</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">              .idx</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">              .promotion_time</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">              .sub_prefix(0u8.into())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">              .range(storage, None, Some(bound), Order::Ascending)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">              .collect::&lt;StdResult&lt;Vec&lt;_ &gt;&gt;&gt;() ?;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>A couple of comments:</p><ul><li><code>joined_key()</code> is being used to create the range key. This helper function transforms the (partial) composite key
composed of batch expiration timestamp and batch id, into a <code>Vec&lt;u8&gt;</code> with the proper format. That is then used to
create a range bound.</li><li><code>sub_prefix()</code> is used to fix the first element of the composite key (the batch status). This is required, because
<code>prefix()</code> in this case (a 3-tuple), implies fixing the first two elements of the key, and we don&#x27;t want / need that
here.</li><li>The iteration proceeds from None to the bound key created from the current timestamp. So that we effectively list only
the still pending but already expired batches.</li></ul><p>That&#x27;s it. After that, we can iterate over the results and change their status from <code>Pending</code> to <code>Promoted</code>, or whatever we
need to do.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/InterWasm/docs/edit/main/tutorials/storage/indexes.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/fr/tutorials/storage/key-value-store"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">How CW Key Value Storage Works?</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/fr/tutorials/storage/state-modeling"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Advanced State Modeling</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#storage-plus-indexing" class="table-of-contents__link toc-highlight">storage-plus indexing</a><ul><li><a href="#unique-indexes" class="table-of-contents__link toc-highlight">Unique Indexes</a></li><li><a href="#multi-indexes" class="table-of-contents__link toc-highlight">Multi Indexes</a></li><li><a href="#composite-multi-indexing" class="table-of-contents__link toc-highlight">Composite Multi Indexing</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Related Documentation</div><ul class="footer__items"><li class="footer__item"><a href="https://cosmos.network/docs" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Cosmos SDK<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://hub.cosmos.network/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Cosmos Hub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://docs.tendermint.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Tendermint Core<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Repositories</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/CosmWasm/cosmwasm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>CosmWasm/cosmwasm<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/CosmWasm/wasmd" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>CosmWasm/wasmd<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/CosmWasm/cw-plus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>CosmWasm/cw-plus<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/InterWasm/cw-contracts" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>InterWasm/cw-contracts<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/InterWasm/cw-awesome" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>InterWasm/cw-awesome<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://medium.com/cosmwasm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://docs.cosmwasm.com/chat/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/CosmWasm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/InterWasm" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>InterWasm<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://cosmwasm.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_RC3H"><img src="/fr/img/logo_stacked.png" alt="CosmWasm Logo" class="themedImage_W2Cr themedImage--light_TfLj footer__logo"><img src="/fr/img/logo_stacked.png" alt="CosmWasm Logo" class="themedImage_W2Cr themedImage--dark_oUvU footer__logo"></a></div><div class="footer__copyright">Copyright Â© 2022 CosmWasm</div></div></div></footer></div>
<script src="/fr/assets/js/runtime~main.573066c5.js"></script>
<script src="/fr/assets/js/main.23c82edf.js"></script>
</body>
</html>