"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4681],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),c=a,g=m["".concat(u,".").concat(c)]||m[c]||d[c]||i;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5057:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return u},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var r=n(3117),a=n(102),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:3},u="Advanced State Modeling",l={unversionedId:"storage/state-modeling",id:"storage/state-modeling",isDocsHomePage:!1,title:"Advanced State Modeling",description:"Under Construction",source:"@site/tutorials/storage/state-modeling.md",sourceDirName:"storage",slug:"/storage/state-modeling",permalink:"/tutorials/storage/state-modeling",editUrl:"https://github.com/InterWasm/docs/edit/main/tutorials/storage/state-modeling.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorials",previous:{title:"Indexes",permalink:"/tutorials/storage/indexes"},next:{title:"Introduction",permalink:"/tutorials/frontend-dapp/intro"}},p=[{value:"Naive Implementation",id:"naive-implementation",children:[],level:2},{value:"Optimized Implementation",id:"optimized-implementation",children:[],level:2},{value:"Back To Business Case",id:"back-to-business-case",children:[],level:2}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"advanced-state-modeling"},"Advanced State Modeling"),(0,i.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Under Construction"))),(0,i.kt)("p",null,"Key Value storage design might be found difficult by SQL background people at the first sight.\nEven though Mongo DB or other streamlined databases are Key Value storage, libraries hide the internal complexity\naway from the developers.\nThis is why Cosmos-SDK storage is not easy in the beginning. Once you get a hold of the concept, it is simple."),(0,i.kt)("p",null,"While implementing state model, take a step back and ask these questions before implementation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Do you really need to save that information to blockchain state?"),(0,i.kt)("li",{parentName:"ul"},"Is that connection really needed? Can it be served to UI by an off-chain database collector?")),(0,i.kt)("p",null,"These question will prevent you from writing unnecessary data to the state, and using excess storage.\nLess storage means cheaper execution."),(0,i.kt)("p",null,"In this tutorial, I will be showing you how to state model for those coming from Mongo DB background"),(0,i.kt)("p",null,"Business Case as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The system will contain persons"),(0,i.kt)("li",{parentName:"ul"},"Persons can become member of multiple groups"),(0,i.kt)("li",{parentName:"ul"},"Group can contain multiple member person"),(0,i.kt)("li",{parentName:"ul"},"Member can have role in a group: admin, super-admin, regular...")),(0,i.kt)("h2",{id:"naive-implementation"},"Naive Implementation"),(0,i.kt)("p",null,"Here is any-to-any relation design with saving data using IDs."),(0,i.kt)("p",null,"Person data indexed using auto incremented ID:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Person {\n    pub name: String,\n    pub age: i32,\n    pub membership_ids: Vec<String>\n}\n\npub const PEOPLE: Map<&[u8], Person> = Map::new("people");\n')),(0,i.kt)("p",null,"Groups indexed with ID too."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Group {\n    pub name: String,\n    pub membership_ids: Vec<String>\n}\n\npub const GROUPS: Map<&[u8], Group> = Map::new("groups");\n')),(0,i.kt)("p",null,"Group and person relation established using membership structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Membership {\n  pub person_id: String,\n  pub group_id: String,\n  pub membership_status_id: String\n}\n\npub const MEMBERSHIPS: Map<&[u8], Membership> = Map::new("memberships");\n')),(0,i.kt)("p",null,"Membership status defined using status ",(0,i.kt)("strong",{parentName:"p"},"String")," field."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct MembershipStatus {\n  pub status: String,\n  pub membership_ids: Vec<String>\n}\n\npub const MEMBERSHIP_STATUSES: Map<&[u8], MembershipStatus> = Map::new("membership_statuses");\n')),(0,i.kt)("h2",{id:"optimized-implementation"},"Optimized Implementation"),(0,i.kt)("p",null,"Firstly, using ID for identifying persons might seem intuitive, but it creates redundancy.\nID is just a value for identifying a user but users already identified by a unique value: ",(0,i.kt)("inlineCode",{parentName:"p"},"Address"),".\nInstead of indexing with auto incremented integers, best is to index with ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Person {\n    pub name: String,\n    pub age: u8, // changed to u8 since ages are unsigned and 100 years max.\n}\n\n// Addr -> Person\npub const PEOPLE: Map<&[u8], Person> = Map::new("people");\n')),(0,i.kt)("p",null,"Removed membership_id. Changed i32 to u8. We don't want to heat up the planet right?\nOptimizing variable types improves gas consumption results as fewer fees."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Now for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Group"),":"),(0,i.kt)("p",null,"Group does not have an address, it makes sense to identify groups using auto-incremented IDs.\nIf you want groups name to be unique, better use name as index."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub const GROUP_COUNTER: Item<u64> = Item::new("group_counter");\n\n#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]\npub struct Group {\n  pub name: String,\n}\n\n// u64 ID -> Group\npub const GROUPS: Map<U64Key, Group> = Map::new("groups");\n')),(0,i.kt)("p",null,"When a group saved, required auto incremented ID saved to ",(0,i.kt)("inlineCode",{parentName:"p"},"GROUP_COUNTER")," item. Best to put this logic under\na function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"\npub fn next_group_counter(store: &mut dyn Storage) -> StdResult<u64> {\n  let id: u64 = GROUP_COUNTER.may_load(store)?.unwrap_or_default() + 1;\n  GROUP_COUNTER.save(store, &id)?;\n  Ok(id)\n}\n\npub fn save_group(store: &mut dyn Storage, group: &Group) -> StdResult<()> {\n  let id = next_group_counter(store)?;\n  let key = U64Key::new(id);\n  NEW_GROUPS.save(store, key, group)\n}\n")),(0,i.kt)("p",null,"Now need to set up relation between group and person also define person's role.\nWhat exactly we want?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Listing users under a group"),(0,i.kt)("li",{parentName:"ul"},"Listing groups of a user")),(0,i.kt)("p",null,"This could be done by building secondary indexes."),(0,i.kt)("h2",{id:"back-to-business-case"},"Back To Business Case"))}m.isMDXComponent=!0}}]);