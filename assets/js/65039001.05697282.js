"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3309],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(t),d=a,g=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return t?r.createElement(g,s(s({ref:n},p),{},{components:t})):r.createElement(g,s({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2854:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c}});var r=t(3117),a=(t(7294),t(3905));const o={sidebar_position:3},s="Develop Contract",i={unversionedId:"simple-option/develop",id:"simple-option/develop",title:"Develop Contract",description:"First test if the starter works, and get your eyes used to rust test results:",source:"@site/tutorials/simple-option/develop.md",sourceDirName:"simple-option",slug:"/simple-option/develop",permalink:"/tutorials/simple-option/develop",draft:!1,editUrl:"https://github.com/InterWasm/docs/edit/main/tutorials/simple-option/develop.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorials",previous:{title:"Setup",permalink:"/tutorials/simple-option/setup"},next:{title:"Testing",permalink:"/tutorials/simple-option/testing"}},l={},c=[{value:"Messages",id:"messages",level:2},{value:"InitMsg",id:"initmsg",level:3},{value:"QueryMsg",id:"querymsg",level:3},{value:"State",id:"state",level:2},{value:"Contract Handlers",id:"contract-handlers",level:2},{value:"Init",id:"init",level:3},{value:"Handle",id:"handle",level:3},{value:"Transfer",id:"transfer",level:4},{value:"Execute",id:"execute",level:4},{value:"Query",id:"query",level:3},{value:"Build",id:"build",level:3},{value:"Tooling",id:"tooling",level:3},{value:"Compile",id:"compile",level:3},{value:"Schema",id:"schema",level:3}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"develop-contract"},"Develop Contract"),(0,a.kt)("iframe",{src:"https://player.vimeo.com/video/457702442",width:"640",height:"360",frameborder:"0",allow:"autoplay; fullscreen",allowfullscreen:!0}),(0,a.kt)("p",null,"First test if the starter works, and get your eyes used to rust test results:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo unit-test\nCompiling proc-macro2 v1.0.24\n  Compiling unicode-xid v0.2.1\n  Compiling syn v1.0.58\n  Compiling serde_derive v1.0.120\n  Compiling serde v1.0.120\n  Compiling ryu v1.0.5\n  Compiling serde_json v1.0.61\n  Compiling schemars v0.7.6\n  Compiling itoa v0.4.7\n  Compiling base64 v0.13.0\n  Compiling quote v1.0.8\n  Compiling serde_derive_internals v0.25.0\n  Compiling schemars_derive v0.7.6\n  Compiling thiserror-impl v1.0.23\n  Compiling cosmwasm-derive v0.13.2\n  Compiling thiserror v1.0.23\n  Compiling serde-json-wasm v0.2.3\n  Compiling cosmwasm-std v0.13.2\n  Compiling cosmwasm-schema v0.13.2\n  Compiling cosmwasm-storage v0.13.2\n  Compiling simple-option v0.8.0 (/home/orkunkl/Workspace/cosmwasm/cw-examples/simple-option)\n    Finished test [unoptimized + debuginfo] target(s) in 25.42s\n      Running target/debug/deps/simple_option-6787c8970c576a03\n\nrunning 4 tests\ntest contract::tests::proper_initialization ... ok\ntest contract::tests::transfer ... ok\ntest contract::tests::burn ... ok\ntest contract::tests::execute ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n")),(0,a.kt)("p",null,"All good."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"}," Timecode ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/457702442#t=39s"},"https://vimeo.com/457702442#t=39s"))),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/blob/main/contracts/simple-option/src/lib.rs"},"src/lib.rs")," file contains wasm\nbindings. Wraps smart contract ",(0,a.kt)("em",{parentName:"p"},"(handle, init, query)")," functions around rust functions. If you are not doing advanced\nwasm tweaking, don't touch it."),(0,a.kt)("h2",{id:"messages"},"Messages"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"}," Timecode ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/457702442#t=1m46s"},"https://vimeo.com/457702442#t=1m46s"))),(0,a.kt)("p",null,"Development begins in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/blob/main/contracts/simple-option/src/msg.rs"},"src/msg.rs"),"\nwhich contains the input data structures of the smart contract."),(0,a.kt)("h3",{id:"initmsg"},"InitMsg"),(0,a.kt)("p",null,"We will begin with ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/blob/main/contracts/simple-option/src/msg.rs"},(0,a.kt)("inlineCode",{parentName:"a"},"InitMsg")),". This\nstruct has the initial values that initializes smart contract from the code and feeds in the data required for logic\nsetup."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InitMsg {\n  // owner and creator come from env\n  // collateral comes from env\n  pub counter_offer: Vec<Coin>,\n  pub expires: u64,\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]")," implements specified traits for this structure\nusing macros. More read ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/rust-by-example/trait/derive.html"},"Rust docs / Derive")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Owner"),", ",(0,a.kt)("em",{parentName:"li"},"creator")," and ",(0,a.kt)("em",{parentName:"li"},"collateral")," comes from message transaction context, meaning owner and creator is the address\nsigned the tx and collateral is funds sent along the message."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"counter_offer")," is ",(0,a.kt)("a",{parentName:"li",href:"https://www.investopedia.com/terms/s/strikeprice.asp"},"strike price"),".\n:::")),(0,a.kt)("h3",{parentName:"admonition",id:"ExecuteMsg"},"ExecuteMsg"),(0,a.kt)("p",{parentName:"admonition"},"Contract execution is branched using ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," enum. Each field defines a message and content of that message."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n  /// Owner can transfer to a new owner\n  Transfer { recipient: HumanAddr },\n  /// Owner can post counter_offer on unexpired option to execute and get the collateral\n  Execute {},\n  /// Burn will release collateral if expired\n  Burn {},\n}\n'))),(0,a.kt)("p",null," Canonical and Human Addresses Canonical Addresses represent binary format of crypto addresses. Human Addresses\non the other hand are great for the UI. They are always a subset of ascii text, and often contain security checks - such\nas chain-prefix in Bech32, e.g. cosmos1h57760w793q6vh06jsppnqdkc4ejcuyrrjxnke"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"canonicalize(humanize(canonical_addr)) == canonical_addr")),(0,a.kt)("p",null,"For more details: ",(0,a.kt)("a",{parentName:"p",href:"https://docs.cosmwasm.com/0.14/architecture/addresses"},"Names and Addresses"),"\n:::"),(0,a.kt)("h3",{id:"querymsg"},"QueryMsg"),(0,a.kt)("p",null,"Smart contract state querying is branched using ",(0,a.kt)("inlineCode",{parentName:"p"},"QueryMsg")," enum. We will implement a smart contract ",(0,a.kt)("inlineCode",{parentName:"p"},"Config")," query\nlater."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum QueryMsg {\n  Config {},\n}\n')),(0,a.kt)("h2",{id:"state"},"State"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"}," Timecode ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/457702442#t=7m36s"},"https://vimeo.com/457702442#t=7m36s"))),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/blob/main/contracts/simple-option/src/state.rs"},"State")," handles state of the\ndatabase where smart contract data is stored and accessed."),(0,a.kt)("p",null,"You have two options when modeling state:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Singleton"),": contract saves only one instance of the structure using unique db key. We will use this in this\ntutorial."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Structured store"),": models can be structured and stored dynamically. You can form one-to-one, one-to-many and\nmany-to-many relations with indexing and lookup functionality.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// configuration instance key. config object will be saved under this key.\npub static CONFIG_KEY: &[u8] = b"config";\n\n// contract state structure, this will be saved.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct State {\n  pub creator: HumanAddr,\n  pub owner: HumanAddr,\n  pub collateral: Vec<Coin>,\n  pub counter_offer: Vec<Coin>,\n  pub expires: u64,\n}\n\npub fn config(storage: &mut dyn Storage) -> Singleton<State> {\n  singleton(storage, CONFIG_KEY)\n}\n\npub fn config_read(storage: &dyn Storage) -> ReadonlySingleton<State> {\n  singleton_read(storage, CONFIG_KEY)\n}\n\n')),(0,a.kt)("h2",{id:"contract-handlers"},"Contract Handlers"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"}," Timecode ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/457702442#t=11m12s"},"https://vimeo.com/457702442#t=11m12s"))),(0,a.kt)("p",null,"Lego bricks ",(0,a.kt)("strong",{parentName:"p"},"msgs"),", ",(0,a.kt)("strong",{parentName:"p"},"handler")," and ",(0,a.kt)("strong",{parentName:"p"},"state")," are defined. Now we need to bind them together\nin ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/blob/main/contracts/simple-option/src/contract.rs"},"contract.rs"),"."),(0,a.kt)("h3",{id:"init"},"Init"),(0,a.kt)("p",null,'The init function will be called exactly once, before the contract is executed. It is a "privileged" function in that it\ncan set configuration that can never be modified by any other method call. The first line parses the input from raw\nbytes into our contract-defined message. We then check if option is expired, then create the initial state. If expired,\nwe return a generic contract error, otherwise, we store the state and return a success code:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn init(\n  deps: DepsMut,\n  env: Env,\n  info: MessageInfo,\n  msg: InitMsg,\n) -> Result<InitResponse, ContractError> {\n  if msg.expires <= env.block.height {\n    return Err(ContractError::OptionExpired {\n      expired: msg.expires,\n    });\n  }\n\n  let state = State {\n    creator: info.sender.clone(),\n    owner: info.sender.clone(),\n    collateral: info.sent_funds,\n    counter_offer: msg.counter_offer,\n    expires: msg.expires,\n  };\n\n  config(deps.storage).save(&state)?;\n\n  Ok(InitResponse::default())\n}\n")),(0,a.kt)("p",null,"The function is simple as it looks. Option expiration date check, save the state, and return response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn init(\n  deps: DepsMut,\n  env: Env,\n  info: MessageInfo,\n  msg: InitMsg,\n) -> Result<InitResponse, ContractError> {\n")),(0,a.kt)("p",null,"You will see this signature all over CosmWasm handler functions. Execution context passed in to handler using Deps,\nwhich contains Storage, API and Querier functions; Env, which contains block, message and contract info; and msg, well,\nno explanation needed."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Result<T, ContractError>")," is a type that represents either success (","[",(0,a.kt)("inlineCode",{parentName:"p"},"Ok"),"]",") or failure (","[",(0,a.kt)("inlineCode",{parentName:"p"},"Err"),"]","). If the execution is\nsuccessful returns ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," type otherwise returns ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractError"),". Useful."),(0,a.kt)("h3",{id:"handle"},"Handle"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"}," Timecode ",(0,a.kt)("a",{parentName:"p",href:"https://vimeo.com/457702442#t=15m55s"},"https://vimeo.com/457702442#t=15m55s"))),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"handle")," method routes messages to functions. It is similar to Cosmos SDK handler design."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn handle(\n  deps: DepsMut,\n  env: Env,\n  info: MessageInfo,\n  msg: ExecuteMsg,\n) -> Result<HandleResponse, ContractError> {\n  match msg {\n    ExecuteMsg::Transfer { recipient } => handle_transfer(deps, env, info, recipient),\n    ExecuteMsg::Execute {} => handle_execute(deps, env, info),\n    ExecuteMsg::Burn {} => handle_burn(deps, env, info),\n  }\n}\n\n")),(0,a.kt)("h4",{id:"transfer"},"Transfer"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn handle_transfer(\n  deps: DepsMut,\n  _env: Env,\n  info: MessageInfo,\n  recipient: HumanAddr,\n) -> Result<HandleResponse, ContractError> {\n  // ensure msg sender is the owner\n  let mut state = config(deps.storage).load()?;\n  if info.sender != state.owner {\n    return Err(ContractError::Unauthorized {});\n  }\n\n  // set new owner on state\n  state.owner = recipient.clone();\n  config(deps.storage).save(&state)?;\n\n  let mut res = Context::new();\n  res.add_attribute("action", "transfer");\n  res.add_attribute("owner", recipient);\n  Ok(res.into())\n}\n')),(0,a.kt)("h4",{id:"execute"},"Execute"),(0,a.kt)("p",null,"You will see ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_execute")," in plus and example smart contracts, but actually it is just a naming, nothing special.\nMost of the function is same with ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer"),". Just two new things: message fund check and sdk messages in return\ncontext."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn handle_execute(\n  deps: DepsMut,\n  env: Env,\n  info: MessageInfo,\n) -> Result<HandleResponse, ContractError> {\n  // ensure msg sender is the owner\n  let state = config(deps.storage).load()?;\n  if info.sender != state.owner {\n    return Err(ContractError::Unauthorized {});\n  }\n\n  // ensure not expired\n  if env.block.height >= state.expires {\n    return Err(ContractError::OptionExpired {\n      expired: state.expires,\n    });\n  }\n\n  // ensure sending proper counter_offer\n  if info.sent_funds != state.counter_offer {\n    return Err(ContractError::CounterOfferMismatch {\n      offer: info.sent_funds,\n      counter_offer: state.counter_offer,\n    });\n  }\n\n  // release counter_offer to creator\n  let mut res = Context::new();\n  res.add_message(BankMsg::Send {\n    from_address: env.contract.address.clone(),\n    to_address: state.creator,\n    amount: state.counter_offer,\n  });\n\n  // release collateral to sender\n  res.add_message(BankMsg::Send {\n    from_address: env.contract.address,\n    to_address: state.owner,\n    amount: state.collateral,\n  });\n\n  // delete the option\n  config(deps.storage).remove();\n\n  res.add_attribute("action", "execute");\n  Ok(res.into())\n}\n')),(0,a.kt)("h3",{id:"query"},"Query"),(0,a.kt)("p",null,"This contracts query method is very simple, only configuration query. For more complex queries\ncheck ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-plus/"},"cosmwasm-plus")," contracts. If you are starting to learn from zero, now\nyou have 20 minutes of cosmwasm experience. Go ahead skim plus contracts to see the simplicity."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n  match msg {\n    QueryMsg::Config {} => to_binary(&query_config(deps)?),\n  }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n  let state = config_read(deps.storage).load()?;\n  Ok(state)\n}\n")),(0,a.kt)("h3",{id:"build"},"Build"),(0,a.kt)("p",null,"To simply build the code and see if it works:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo build\n")),(0,a.kt)("h3",{id:"tooling"},"Tooling"),(0,a.kt)("p",null,"It is good to keep the same coding style across smart contracts for readability and lint it for high code quality:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"rustup update\nrustup component add clippy rustfmt\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo fmt\n")),(0,a.kt)("p",null,"Normally Rust compiler does its job great, leads you to the solution for the errors, shows warnings etc. But it is\nalways good to run linter on the code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo clippy -- -D warnings\n")),(0,a.kt)("h3",{id:"compile"},"Compile"),(0,a.kt)("p",null,"This section compiles key commands from ",(0,a.kt)("a",{parentName:"p",href:"https://docs.cosmwasm.com/0.14/getting-started/compile-contract"},"Compiling Contract")," doc.\nFor more\ndetailed read proceed to the documentation."),(0,a.kt)("p",null,"Basic compilation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo wasm\n")),(0,a.kt)("p",null,"Optimized compilation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"RUSTFLAGS='-C link-arg=-s' cargo wasm\n")),(0,a.kt)("p",null,"Reproducible and optimized compilation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'docker run --rm -v "$(pwd)":/code \\\n  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer:0.10.7\n')),(0,a.kt)("p",null,"On Windows, you can use the following command instead"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-powershell"},'docker run --rm -v ${pwd}:/code `\n --mount type=volume,source="$("$(Split-Path -Path $pwd -Leaf)")_cache",target=/code/target `\n --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry `\n cosmwasm/rust-optimizer:0.10.7\n')),(0,a.kt)("p",null,"You want to use the command above before deploying to the chain."),(0,a.kt)("h3",{id:"schema"},"Schema"),(0,a.kt)("p",null,'We can also generate JSON Schemas that serve as a guide for anyone trying to use the contract. This is mainly for\ndocumentation purposes, but if you click on "Open TypeScript definitions" in the code explorer, you can see how we use\nthose to generate TypeScript bindings.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"cargo schema\n")),(0,a.kt)("p",null,"You can see the generated schemas\nunder ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-examples/tree/main/contracts/simple-option/schema"},"simple-option/schema")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"schema\n\u251c\u2500\u2500 config_response.json\n\u251c\u2500\u2500 handle_msg.json\n\u251c\u2500\u2500 init_msg.json\n\u2514\u2500\u2500 query_msg.json\n")),(0,a.kt)("p",null,"Go ahead and explore schemas."))}u.isMDXComponent=!0}}]);