"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1693],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(t),u=r,k=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return t?a.createElement(k,s(s({ref:n},d),{},{components:t})):a.createElement(k,s({ref:n},d))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1993:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),s=["components"],o={sidebar_position:7},l="Migrating Contracts",p={unversionedId:"MIGRATING",id:"version-0.16/MIGRATING",title:"Migrating Contracts",description:"This guide explains what is needed to upgrade contracts when migrating over major releases of cosmwasm. Note that you",source:"@site/docs_versioned_docs/version-0.16/07-MIGRATING.md",sourceDirName:".",slug:"/MIGRATING",permalink:"/docs/0.16/MIGRATING",editUrl:"https://github.com/InterWasm/docs/edit/main/docs_versioned_docs/version-0.16/07-MIGRATING.md",tags:[],version:"0.16",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"version-0.16/docsSidebar",previous:{title:"Compatibility",permalink:"/docs/0.16/COMPATIBILITY"},next:{title:"CHANGELOG",permalink:"/docs/0.16/CHANGELOG"}},d=[{value:"0.15 -&gt; 0.16",id:"015---016",children:[],level:2},{value:"0.14 -&gt; 0.15",id:"014---015",children:[],level:2},{value:"0.13 -&gt; 0.14",id:"013---014",children:[],level:2},{value:"0.12 -&gt; 0.13",id:"012---013",children:[],level:2},{value:"0.11 -&gt; 0.12",id:"011---012",children:[],level:2},{value:"0.10 -&gt; 0.11",id:"010---011",children:[],level:2},{value:"0.9 -&gt; 0.10",id:"09---010",children:[],level:2},{value:"0.8 -&gt; 0.9",id:"08---09",children:[],level:2},{value:"0.7.2 -&gt; 0.8",id:"072---08",children:[{value:"Update wasm code",id:"update-wasm-code",children:[],level:3},{value:"Update test code",id:"update-test-code",children:[],level:3},{value:"Update schema code",id:"update-schema-code",children:[],level:3},{value:"Polishing",id:"polishing",children:[],level:3}],level:2}],m={toc:d};function c(e){var n=e.components,t=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"migrating-contracts"},"Migrating Contracts"),(0,i.kt)("p",null,"This guide explains what is needed to upgrade contracts when migrating over major releases of ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm"),". Note that you\ncan also view the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/0.16/CHANGELOG"},"complete CHANGELOG")," to understand the differences."),(0,i.kt)("h2",{id:"015---016"},"0.15 -> 0.16"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.16.0"\ncosmwasm-storage = "0.16.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.16.0"\ncosmwasm-vm = "0.16.0"\n# ...\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"attr")," function now accepts arguments that implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Into<String>")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"ToString"),'. This means that "\nstringly" types like ',(0,i.kt)("inlineCode",{parentName:"p"},"&str")," are still accepted, but others (like numbers or booleans) have to be explicitly converted\nto strings; you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"to_string")," method (from the\n",(0,i.kt)("inlineCode",{parentName:"p"},"std::string::ToString")," trait) for that."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'  let steal_funds = true;\n- attr("steal_funds", steal_funds),\n+ attr("steal_funds", steal_funds.to_string()),\n')),(0,i.kt)("p",{parentName:"li"},"It also means that ",(0,i.kt)("inlineCode",{parentName:"p"},"&&str")," is no longer accepted.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"iterator")," feature in ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm-std"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm-vm")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm-storage"),"\nis now enabled by default. If you want to use it, you don't have to explicitly enable it anymore."),(0,i.kt)("p",{parentName:"li"},"If you don't want to use it, you ",(0,i.kt)("strong",{parentName:"p"},"have to")," disable default features when depending on ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm-std"),". Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- cosmwasm-std = { version = "0.15.0" }\n+ cosmwasm-std = { version = "0.16.0", default-features = false }\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Event::attr")," setter has been renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Event::add_attribute")," - this is for consistency with other types,\nlike ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),"."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- let event = Event::new("ibc").attr("channel", "connect");\n+ let event = Event::new("ibc").add_attribute("channel", "connect");\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Response")," can no longer be built using a struct literal. Please use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Response::new")," as well as relevant\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/blob/402e3281ff5bc1cd7b4b3e36c2bb9914f07eaaf6/packages/std/src/results/response.rs#L103-L167"},"builder-style setters"),"\nto set the data."),(0,i.kt)("p",{parentName:"li"},"This is a step toward better API stability."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'  #[entry_point]\n  pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -> StdResult<Response> {\n      // ...\n\n      let send = BankMsg::Send {\n          to_address: msg.payout.clone(),\n          amount: balance,\n      };\n      let data_msg = format!("burnt {} keys", count).into_bytes();\n\n-     Ok(Response {\n-         messages: vec![SubMsg::new(send)],\n-         attributes: vec![attr("action", "burn"), attr("payout", msg.payout)],\n-         events: vec![],\n-         data: Some(data_msg.into()),\n-     })\n+     Ok(Response::new()\n+         .add_message(send)\n+         .add_attribute("action", "burn")\n+         .add_attribute("payout", msg.payout)\n+         .set_data(data_msg))\n  }\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- Ok(Response {\n-     data: Some((old_size as u32).to_be_bytes().into()),\n-     ..Response::default()\n- })\n+ Ok(Response::new().set_data((old_size as u32).to_be_bytes()))\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'- let res = Response {\n-     messages: msgs,\n-     attributes: vec![attr("action", "reflect_subcall")],\n-     events: vec![],\n-     data: None,\n- };\n- Ok(res)\n+ Ok(Response::new()\n+     .add_attribute("action", "reflect_subcall")\n+     .add_submessages(msgs))\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For IBC-enabled contracts only: constructing ",(0,i.kt)("inlineCode",{parentName:"p"},"IbcReceiveResponse")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"IbcBasicResponse")," follows the same principles now as ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," above."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'  pub fn ibc_packet_receive(\n      deps: DepsMut,\n      env: Env,\n      msg: IbcPacketReceiveMsg,\n  ) -> StdResult<IbcReceiveResponse> {\n      // ...\n\n-     Ok(IbcReceiveResponse {\n-         acknowledgement,\n-         messages: vec![],\n-         attributes: vec![],\n-         events: vec![Event::new("ibc").attr("packet", "receive")],\n-     })\n+     Ok(IbcReceiveResponse::new()\n+         .set_ack(acknowledgement)\n+         .add_event(Event::new("ibc").add_attribute("packet", "receive")))\n  }\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For IBC-enabled contracts only: IBC entry points have different signatures. Instead of accepting bare packets,\nchannels and acknowledgements, all of those are wrapped in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Msg")," type specific to the given entry point. Channels,\npackets and acknowledgements have to be unpacked from those."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n- pub fn ibc_channel_open(_deps: DepsMut, _env: Env, channel: IbcChannel) -> StdResult<()> {\n+ pub fn ibc_channel_open(_deps: DepsMut, _env: Env, msg: IbcChannelOpenMsg) -> StdResult<()> {\n+     let channel = msg.channel();\n\n      // do things\n  }\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n  pub fn ibc_channel_connect(\n      deps: DepsMut,\n      env: Env,\n-     channel: IbcChannel,\n+     msg: IbcChannelConnectMsg,\n  ) -> StdResult<IbcBasicResponse> {\n+     let channel = msg.channel();\n\n      // do things\n  }\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n  pub fn ibc_channel_close(\n      deps: DepsMut,\n      env: Env,\n-     channel: IbcChannel,\n+     msg: IbcChannelCloseMsg,\n  ) -> StdResult<IbcBasicResponse> {\n+     let channel = msg.channel();\n\n      // do things\n  }\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n  pub fn ibc_packet_receive(\n      deps: DepsMut,\n      env: Env,\n-     packet: IbcPacket,\n+     msg: IbcPacketReceiveMsg,\n  ) -> StdResult<IbcReceiveResponse> {\n+     let packet = msg.packet;\n\n      // do things\n  }\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n  pub fn ibc_packet_receive(\n      deps: DepsMut,\n      env: Env,\n-     ack: IbcAcknowledgementWithPacket,\n+     msg: IbcPacketReceiveMsg,\n  ) -> StdResult<IbcBasicResponse> {\n      // They are the same struct just a different name\n      let ack = msg;\n\n      // do things\n  }\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  #[entry_point]\n  pub fn ibc_packet_timeout(\n      deps: DepsMut,\n      env: Env,\n-     packet: IbcPacket,\n+     msg: IbcPacketTimeoutMsg,\n  ) -> StdResult<IbcBasicResponse> {\n+     let packet = msg.packet;\n\n      // do things\n  }\n")))),(0,i.kt)("h2",{id:"014---015"},"0.14 -> 0.15"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.15.0"\ncosmwasm-storage = "0.15.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.15.0"\ncosmwasm-vm = "0.15.0"\n# ...\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Combine ",(0,i.kt)("inlineCode",{parentName:"p"},"messages")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"submessages")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," object. The new format uses ",(0,i.kt)("inlineCode",{parentName:"p"},"messages: Vec<SubMsg<T>>"),", so\ncopy ",(0,i.kt)("inlineCode",{parentName:"p"},"submessages")," content, and wrap old messages using ",(0,i.kt)("inlineCode",{parentName:"p"},"SubMsg::new"),". Here is how to change messages:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let send = BankMsg::Send { to_address, amount };\n\n// before\nlet res = Response {\n  messages: vec![send.into()],\n  ..Response::default()\n}\n\n// after\nlet res = Response {\n  messages: vec![SubMsg::new(send)],\n  ..Response::default()\n}\n\n// alternate approach\nlet mut res = Response::new();\nres.add_message(send);\n")),(0,i.kt)("p",{parentName:"li"},"And here is how to change submessages:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\nlet sub_msg = SubMsg {\n  id: INIT_CALLBACK_ID,\n  msg: msg.into(),\n  gas_limit: None,\n  reply_on: ReplyOn::Success,\n};\nlet res = Response {\n  submessages: vec![sub_msg],\n  ..Response::default()\n};\n\n// after\nlet msg = SubMsg::reply_on_success(msg, INIT_CALLBACK_ID);\nlet res = Response {\n  messages: vec![msg],\n  ..Response::default()\n};\n\n// alternate approach\nlet msg = SubMsg::reply_on_success(msg, INIT_CALLBACK_ID);\nlet mut res = Response::new();\nres.add_submessage(msg);\n")),(0,i.kt)("p",{parentName:"li"},'Note that this means you can mix "messages" and "submessages" in any execution order. You are no more restricted to\ndoing "submessages" first.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename the ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," field to ",(0,i.kt)("inlineCode",{parentName:"p"},"funds")," whenever constructing a ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmMsg::Execute"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmMsg::Instantiate")," value."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  let exec = WasmMsg::Execute {\n      contract_addr: coin.address.into(),\n      msg: to_binary(&msg)?,\n-     send: vec![],\n+     funds: vec![],\n  };\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Uint128")," field can no longer be constructed using a struct literal. Call\n",(0,i.kt)("inlineCode",{parentName:"p"},"Uint128::new")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint128::zero"),") instead."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- const TOKENS_PER_WEIGHT: Uint128 = Uint128(1_000);\n- const MIN_BOND: Uint128 = Uint128(5_000);\n+ const TOKENS_PER_WEIGHT: Uint128 = Uint128::new(1_000);\n+ const MIN_BOND: Uint128 = Uint128::new(5_000);\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"- assert_eq!(escrow_balance, Uint128(0));\n+ assert_eq!(escrow_balance, Uint128::zero());\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If constructing a ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," using struct literal syntax, add the ",(0,i.kt)("inlineCode",{parentName:"p"},"events"),"\nfield."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"  Ok(Response {\n      messages: vec![],\n      attributes,\n+     events: vec![],\n      data: None,\n  })\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For IBC-enabled contracts only: You need to adapt to the new\n",(0,i.kt)("inlineCode",{parentName:"p"},"IbcAcknowledgementWithPacket")," structure and use the embedded ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," field:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\npub fn ibc_packet_ack(\n  deps: DepsMut,\n  env: Env,\n  ack: IbcAcknowledgement,\n) -> StdResult<Response> {\n  let res: AcknowledgementMsg = from_slice(&ack.acknowledgement)?;\n  // ...\n}\n\n// after\npub fn ibc_packet_ack(\n  deps: DepsMut,\n  env: Env,\n  ack: IbcAcknowledgementWithPacket,\n) -> StdResult<Response> {\n  let res: AcknowledgementMsg = from_slice(&ack.acknowledgement.data)?;\n  // ...\n}\n")),(0,i.kt)("p",{parentName:"li"},"You also need to update the constructors in test code. Below we show how to do so both for JSON data as well as any\ncustom binary format:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before (JSON)\nlet ack = IbcAcknowledgement {\n  acknowledgement: to_binary(&AcknowledgementMsg::Ok(())).unwrap()\n  original_packet: packet,\n};\n\n// after (JSON)\nlet ack = IbcAcknowledgementWithPacket {\n    acknowledgement: IbcAcknowledgement::encode_json(&AcknowledgementMsg::Ok(())).unwrap(),\n    original_packet: packet,\n};\n\n// before (Custom binary data)\nlet acknowledgement = vec![12, 56, 78];\nlet ack = IbcAcknowledgement {\n  acknowledgement: Binary(acknowledgement),\n  original_packet: packet,\n};\n\n// after (Custom binary data)\nlet acknowledgement = vec![12, 56, 78];\nlet ack = IbcAcknowledgement {\n  acknowledgement: IbcAcknowledgement::new(acknowledgement),\n  original_packet: packet,\n};\n")))),(0,i.kt)("h2",{id:"013---014"},"0.13 -> 0.14"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The minimum Rust supported version for 0.14 is 1.51.0. Verify your Rust version is >= 1.51.0 with: ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc --version"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm and schemars dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.14.0"\ncosmwasm-storage = "0.14.0"\nschemars = "0.8.1"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.14.0"\ncosmwasm-vm = "0.14.0"\n# ...\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename the ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," entry point to ",(0,i.kt)("inlineCode",{parentName:"p"},"instantiate"),". Also, rename ",(0,i.kt)("inlineCode",{parentName:"p"},"InitMsg")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"InstantiateMsg"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename the ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," entry point to ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),". Also, rename ",(0,i.kt)("inlineCode",{parentName:"p"},"HandleMsg")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"ExecuteMsg"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename ",(0,i.kt)("inlineCode",{parentName:"p"},"InitResponse"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"HandleResponse")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MigrateResponse")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),". The old names are still supported (with a\ndeprecation warning), and will be removed in the next version. Also, you'll need to add the ",(0,i.kt)("inlineCode",{parentName:"p"},"submessages")," field\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Remove ",(0,i.kt)("inlineCode",{parentName:"p"},"from_address")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"BankMsg::Send"),", which is now automatically filled with the contract address:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\nctx.add_message(BankMsg::Send {\n    from_address: env.contract.address,\n    to_address: to_addr,\n    amount: balance,\n});\n\n// after\nctx.add_message(BankMsg::Send {\n    to_address: to_addr,\n    amount: balance,\n});\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use the new entry point system. From ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs")," remove"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points!(contract);\n\n// or\n\n#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points_with_migration!(contract);\n')),(0,i.kt)("p",{parentName:"li"},"Then add the macro attribute ",(0,i.kt)("inlineCode",{parentName:"p"},"#[entry_point]")," to your ",(0,i.kt)("inlineCode",{parentName:"p"},"contract.rs")," as follows:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use cosmwasm_std::{entry_point, \u2026 };\n\n// \u2026\n\n#[entry_point]\npub fn init(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: InitMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n#[entry_point]\npub fn execute(\n    _deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    _msg: ExecuteMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n// only if you have migrate\n#[entry_point]\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: MigrateMsg,\n) -> StdResult<Response> {\n    // \u2026\n}\n\n#[entry_point]\npub fn query(_deps: Deps, _env: Env, _msg: QueryMsg) -> StdResult<QueryResponse> {\n    // \u2026\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," field, converting ",(0,i.kt)("inlineCode",{parentName:"p"},"Context")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"Response"),"\nalways succeeds."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\npub fn init(deps: DepsMut, env: Env, info: MessageInfo, msg: InitMsg) -> Result<InitResponse, HackError> {\n    // \u2026\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.try_into()?)\n}\n\n// after\npub fn init(deps: DepsMut, env: Env, info: MessageInfo, msg: InitMsg) -> Result<Response, HackError> {\n    // \u2026\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.into())\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"info: MessageInfo")," field from the ",(0,i.kt)("inlineCode",{parentName:"p"},"migrate")," entry point:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// Before\npub fn migrate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: MigrateMsg,\n) -> StdResult<MigrateResponse> {\n  // ...\n}\n\n// After\npub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -> StdResult<Response> {\n  // ...\n}\n")),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"MessageInfo::funds")," was always empty since ","[MsgMigrateContract]"," does not have a funds field. ",(0,i.kt)("inlineCode",{parentName:"p"},"MessageInfo::sender"),"\nshould not be needed for authentication because the chain checks permissions before calling ",(0,i.kt)("inlineCode",{parentName:"p"},"migrate"),". If the sender's\naddress is needed for anything else, this should be expressed as part of the migrate message."),(0,i.kt)("p",{parentName:"li"},"msgmigratecontract:\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L86-L96"},"https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L86-L96"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add mutating helper methods to ",(0,i.kt)("inlineCode",{parentName:"p"},"Response")," that can be used instead of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Context")," that is later converted to\na response:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\npub fn handle_impl(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    // ...\n\n    // release counter_offer to creator\n    let mut ctx = Context::new();\n    ctx.add_message(BankMsg::Send {\n        to_address: state.creator,\n        amount: state.counter_offer,\n    });\n\n    // release collateral to sender\n    ctx.add_message(BankMsg::Send {\n        to_address: state.owner,\n        amount: state.collateral,\n    });\n\n    // ..\n\n    ctx.add_attribute("action", "execute");\n    Ok(ctx.into())\n}\n')))),(0,i.kt)("p",null,"  // after\npub fn execute_impl(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n// ..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  // release counter_offer to creator\n  let mut resp = Response::new();\n  resp.add_message(BankMsg::Send {\n      to_address: state.creator,\n      amount: state.counter_offer,\n  });\n\n  // release collateral to sender\n  resp.add_message(BankMsg::Send {\n      to_address: state.owner,\n      amount: state.collateral,\n  });\n\n  // ..\n\n  resp.add_attribute("action", "execute");\n  Ok(resp)\n')),(0,i.kt)("p",null,"  }"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n- Use type `Pair` instead of `KV`\n\n```rust\n// before\nuse cosmwasm_std::KV;\n\n// after\nuse cosmwasm_std::Pair;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If necessary, add a wildcard arm to the ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," of now non-exhaustive message types ",(0,i.kt)("inlineCode",{parentName:"p"},"BankMsg"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"BankQuery"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmMsg"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"WasmQuery"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"HumanAddr")," has been deprecated in favour of simply ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". It never added any significant safety bonus\nover ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," and was just a marker type. The new type ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr")," was created to hold validated addresses. Those can be\ncreated via\n",(0,i.kt)("inlineCode",{parentName:"p"},"Addr::unchecked"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Api::addr_validate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Api::addr_humanize")," and JSON deserialization. In order to maintain type\nsafety, deserialization into ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr"),"\nmust only be done from trusted sources like a contract's state or a query response. User inputs must be deserialized\ninto ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". This new ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr")," type makes it easy to use human readable addresses in state:"),(0,i.kt)("p",{parentName:"li"},"With pre-validated ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"MessageInfo"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\npub struct State {\n    pub owner: CanonicalAddr,\n}\n\nlet state = State {\n    owner: deps.api.canonical_address(&info.sender /* of type HumanAddr */)?,\n};\n")))),(0,i.kt)("p",null,"  // after\npub struct State {\npub owner: Addr,\n}\nlet state = State {\nowner: info.sender.clone() /",(0,i.kt)("em",{parentName:"p"}," of type Addr "),"/,\n};"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\nWith user input in `msg`:\n\n```rust\n// before\npub struct State {\n    pub verifier: CanonicalAddr,\n    pub beneficiary: CanonicalAddr,\n    pub funder: CanonicalAddr,\n}\n\ndeps.storage.set(\n    CONFIG_KEY,\n    &to_vec(&State {\n        verifier: deps.api.canonical_address(&msg.verifier /* of type HumanAddr */)?,\n        beneficiary: deps.api.canonical_address(&msg.beneficiary /* of type HumanAddr */)?,\n        funder: deps.api.canonical_address(&info.sender /* of type HumanAddr */)?,\n    })?,\n);\n\n// after\npub struct State {\n    pub verifier: Addr,\n    pub beneficiary: Addr,\n    pub funder: Addr,\n}\n\ndeps.storage.set(\n    CONFIG_KEY,\n    &to_vec(&State {\n        verifier: deps.api.addr_validate(&msg.verifier /* of type String */)?,\n        beneficiary: deps.api.addr_validate(&msg.beneficiary /* of type String */)?,\n        funder: info.sender /* of type Addr */,\n    })?,\n);\n")),(0,i.kt)("p",null,"  The existing ",(0,i.kt)("inlineCode",{parentName:"p"},"CanonicalAddr")," remains unchanged and can be used in cases in which a compact binary representation is\ndesired. For JSON state this does not save much data (e.g. the bech32 address\ncosmos1pfq05em6sfkls66ut4m2257p7qwlk448h8mysz takes 45 bytes as direct ASCII and 28 bytes when its canonical\nrepresentation is base64 encoded). For fixed length database keys ",(0,i.kt)("inlineCode",{parentName:"p"},"CanonicalAddr")," remains handy though."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Replace ",(0,i.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"DistributionMsg::SetWithdrawAddress")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"DistributionMsg::WithdrawDelegatorReward"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," was a shorthand for the two distribution messages.\nHowever, it was unintuitive because it did not set the address for one withdraw only but for all following withdrawls.\nSince withdrawls are ",(0,i.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/v0.42/modules/distribution/"},"triggered by different events")," such as validators changing their commission\nrate, an address that was set for a one-time withdrawl would be used for future withdrawls not considered by the\ncontract author."),(0,i.kt)("p",{parentName:"li"},"If the contract never set a withdraw address other than the contract itself\n(",(0,i.kt)("inlineCode",{parentName:"p"},"env.contract.address"),"), you can simply replace ",(0,i.kt)("inlineCode",{parentName:"p"},"StakingMsg::Withdraw")," with\n",(0,i.kt)("inlineCode",{parentName:"p"},"DistributionMsg::WithdrawDelegatorReward"),". It is then never changed from the default. Otherwise you need to carefully\ntrack what the current withdraw address is. A one-time change can be implemented by emitted 3 messages:"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SetWithdrawAddress { address: recipient }")," to temporarily change the recipient"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"WithdrawDelegatorReward { validator }")," to do a manual withdrawl from the given validator"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SetWithdrawAddress { address: env.contract.address.into() }")," to change it back for all future withdrawls"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The block time in ",(0,i.kt)("inlineCode",{parentName:"p"},"env.block.time")," is now a ",(0,i.kt)("inlineCode",{parentName:"p"},"Timestamp")," which stores nanosecond precision. ",(0,i.kt)("inlineCode",{parentName:"p"},"env.block.time_nanos")," was\nremoved. If you need the compnents as before, use"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let seconds = env.block.time.nanos() / 1_000_000_000;\nlet nsecs = env.block.time.nanos() % 1_000_000_000;\n")))),(0,i.kt)("h2",{id:"012---013"},"0.12 -> 0.13"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The minimum Rust supported version for 0.13 is 1.47.0."),(0,i.kt)("p",{parentName:"li"},"Verify your Rust version is >= 1.47.0:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"rustc -V\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.13.0"\ncosmwasm-storage = "0.13.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.13.0"\ncosmwasm-vm = "0.13.0"\n# ...\n')))),(0,i.kt)("h2",{id:"011---012"},"0.11 -> 0.12"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.12.0"\ncosmwasm-storage = "0.12.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.12.0"\ncosmwasm-vm = "0.12.0"\n# ...\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In your contract's ",(0,i.kt)("inlineCode",{parentName:"p"},".cargo/config")," remove ",(0,i.kt)("inlineCode",{parentName:"p"},"--features backtraces"),", which is now available in Rust nightly only:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-diff"},'@@ -1,6 +1,6 @@\n [alias]\n wasm = "build --release --target wasm32-unknown-unknown"\n wasm-debug = "build --target wasm32-unknown-unknown"\n-unit-test = "test --lib --features backtraces"\n+unit-test = "test --lib"\n integration-test = "test --test integration"\n schema = "run --example schema"\n')),(0,i.kt)("p",{parentName:"li"},"In order to use backtraces for debugging, run\n",(0,i.kt)("inlineCode",{parentName:"p"},"RUST_BACKTRACE=1 cargo +nightly unit-test --features backtraces"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Extern")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Deps"),", and radically simplify the\n",(0,i.kt)("inlineCode",{parentName:"p"},"init"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"handle"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"migrate"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"query")," entrypoints. Rather than\n",(0,i.kt)("inlineCode",{parentName:"p"},"&mut Extern<S, A, Q>"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"DepsMut"),". And instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"&Extern<S, A, Q>"),", use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Deps"),". If you ever pass eg. ",(0,i.kt)("inlineCode",{parentName:"p"},"foo<A: Api>(api: A)")," around, you must now use dynamic trait\npointers: ",(0,i.kt)("inlineCode",{parentName:"p"},"foo(api: &dyn Api)"),". Here is the quick search-replace guide on how to fix ",(0,i.kt)("inlineCode",{parentName:"p"},"contract.rs"),":"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"In production (non-test) code:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<S: Storage, A: Api, Q: Querier>")," => ``"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&mut Extern<S, A, Q>")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"DepsMut")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&Extern<S, A, Q>")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"Deps")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&mut deps.storage")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"deps.storage")," where passing into ",(0,i.kt)("inlineCode",{parentName:"li"},"state.rs")," helpers"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&deps.storage")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"deps.storage")," where passing into ",(0,i.kt)("inlineCode",{parentName:"li"},"state.rs")," helpers")),(0,i.kt)("p",{parentName:"li"},"On the top, remove ",(0,i.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Api, Extern, Querier, Storage}"),". Add\n",(0,i.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Deps, DepsMut}"),"."),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"In test code only:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&mut deps,")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"deps.as_mut(),")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&deps,")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"deps.as_ref(),"))),(0,i.kt)("p",{parentName:"li"},"You may have to add ",(0,i.kt)("inlineCode",{parentName:"p"},"use cosmwasm_std::{Storage}")," if the compile complains about the trait"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"If you use cosmwasm-storage, in ",(0,i.kt)("inlineCode",{parentName:"em"},"state.rs"),":")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<S: Storage>")," => ``"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<S: ReadonlyStorage>")," => ``"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<S,")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"<")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&mut S")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"&mut dyn Storage")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&S")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"&dyn Storage")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you have any references to ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyStorage")," left after the above, please replace them with ",(0,i.kt)("inlineCode",{parentName:"p"},"Storage")))),(0,i.kt)("h2",{id:"010---011"},"0.10 -> 0.11"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.11.0"\ncosmwasm-storage = "0.11.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.11.0"\ncosmwasm-vm = "0.11.0"\n# ...\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Contracts now support any custom error type ",(0,i.kt)("inlineCode",{parentName:"p"},"E: ToString + From<StdError>"),". Previously this has been ",(0,i.kt)("inlineCode",{parentName:"p"},"StdError"),", which\nyou can still use. However, you can now create a much more structured error experience for your unit tests that\nhandels exactly the error cases of your contract. In order to get a convenient implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"ToString"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"From<StdError>"),", we use the crate\n",(0,i.kt)("a",{parentName:"p",href:"https://crates.io/crates/thiserror"},"thiserror"),", which needs to be added to the contracts dependencies in ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"\n. To create the custom error, create an error module ",(0,i.kt)("inlineCode",{parentName:"p"},"src/errors.rs")," as follows:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use cosmwasm_std::{CanonicalAddr, StdError};\nuse thiserror::Error;\n\n// thiserror implements Display and ToString if you\n// set the `#[error("\u2026")]` attribute for all cases\n#[derive(Error, Debug)]\npub enum MyCustomError {\n    #[error("{0}")]\n    // let thiserror implement From<StdError> for you\n    Std(#[from] StdError),\n    // this is whatever we want\n    #[error("Permission denied: the sender is not the current owner")]\n    NotCurrentOwner {\n        expected: CanonicalAddr,\n        actual: CanonicalAddr,\n    },\n    #[error("Messages empty. Must reflect at least one message")]\n    MessagesEmpty,\n}\n')),(0,i.kt)("p",{parentName:"li"},"Then add ",(0,i.kt)("inlineCode",{parentName:"p"},"mod errors;")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"src/lib.rs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"use crate::errors::MyCustomError;"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"src/contract.rs"),". Now adapt the return types as follows:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn init"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Result<InitResponse, MyCustomError>"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn migrate")," (if you have it): ",(0,i.kt)("inlineCode",{parentName:"li"},"Result<MigrateResponse, MyCustomError>"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn handle"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Result<HandleResponse, MyCustomError>"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn query"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Result<Binary, MyCustomError>"),".")),(0,i.kt)("p",{parentName:"li"},"If one of your funtions does not use the custom error, you can continue to use\n",(0,i.kt)("inlineCode",{parentName:"p"},"StdError")," as before. I.e. you can have ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," returning\n",(0,i.kt)("inlineCode",{parentName:"p"},"Result<HandleResponse, MyCustomError>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," returning\n",(0,i.kt)("inlineCode",{parentName:"p"},"StdResult<Binary>"),"."),(0,i.kt)("p",{parentName:"li"},"You can have a top-hevel ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"migrate"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"handle"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"query")," that returns a custom error but some of its implementations\nonly return errors from the standard library (",(0,i.kt)("inlineCode",{parentName:"p"},"StdResult<HandleResponse>")," aka.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Result<HandleResponse, StdError>"),"). Then use ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok(std_result?)")," to convert between the result types. E.g."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn handle<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: HandleMsg,\n) -> Result<HandleResponse, StakingError> {\n    match msg {\n        // conversion to Result<HandleResponse, StakingError>\n        HandleMsg::Bond {} => Ok(bond(deps, env)?),\n        // this already returns Result<HandleResponse, StakingError>\n        HandleMsg::_BondAllTokens {} => _bond_all_tokens(deps, env),\n    }\n}\n")),(0,i.kt)("p",{parentName:"li"},"or"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: InitMsg,\n) -> Result<InitResponse, HackError> {\n    // \u2026\n\n    let mut ctx = Context::new();\n    ctx.add_attribute("Let the", "hacking begin");\n    Ok(ctx.try_into()?)\n}\n')),(0,i.kt)("p",{parentName:"li"},"Once you got familiar with the concept, you can create different error types for each of the contract's functions."),(0,i.kt)("p",{parentName:"li"},"You can also try a different error library than\n",(0,i.kt)("a",{parentName:"p",href:"https://crates.io/crates/thiserror"},"thiserror"),". The\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/tree/master/contracts/staking"},"staking development contract"),"\nshows how this would look like using ",(0,i.kt)("a",{parentName:"p",href:"https://crates.io/crates/snafu"},"snafu"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Change order of arguments such that ",(0,i.kt)("inlineCode",{parentName:"p"},"storage")," is always first followed by namespace in ",(0,i.kt)("inlineCode",{parentName:"p"},"Bucket::new"),"\n, ",(0,i.kt)("inlineCode",{parentName:"p"},"Bucket::multilevel"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyBucket::new"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyBucket::multilevel"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PrefixedStorage::new"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"PrefixedStorage::multilevel"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyPrefixedStorage::new"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyPrefixedStorage::multilevel"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bucket"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bucket_read"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"prefixed")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"prefixed_read"),"."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut bucket = bucket::<_, Data>(b"data", &mut store);\n\n// after\nlet mut bucket = bucket::<_, Data>(&mut store, b"data");\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename ",(0,i.kt)("inlineCode",{parentName:"p"},"InitResponse::log"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MigrateResponse::log")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"HandleResponse::log"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"InitResponse::attributes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MigrateResponse::attributes")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"HandleResponse::attributes"),". Replace calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"attr"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nOk(HandleResponse {\n  log: vec![log("action", "change_owner"), log("owner", owner)],\n  ..HandleResponse::default()\n})\n\n// after\nOk(HandleResponse {\n  attributes: vec![attr("action", "change_owner"), attr("owner", owner)],\n  ..HandleResponse::default()\n})\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rename ",(0,i.kt)("inlineCode",{parentName:"p"},"Context::add_log")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Context::add_attribute"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut ctx = Context::new();\nctx.add_log("action", "release");\nctx.add_log("destination", &to_addr);\n\n// after\nlet mut ctx = Context::new();\nctx.add_attribute("action", "release");\nctx.add_attribute("destination", &to_addr);\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add result type to ",(0,i.kt)("inlineCode",{parentName:"p"},"Bucket::update")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Singleton::update"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nbucket.update(b"maria", |mayd: Option<Data>| {\n  let mut d = mayd.ok_or(StdError::not_found("Data"))?;\n  old_age = d.age;\n  d.age += 1;\n  Ok(d)\n})\n\n// after\nbucket.update(b"maria", |mayd: Option<Data>| -> StdResult<_> {\n  let mut d = mayd.ok_or(StdError::not_found("Data"))?;\n  old_age = d.age;\n  d.age += 1;\n  Ok(d)\n})\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Remove all ",(0,i.kt)("inlineCode",{parentName:"p"},"canonical_length")," arguments from mock APIs in tests:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet mut deps = mock_dependencies(20, &[]);\nlet mut deps = mock_dependencies(20, &coins(123456, "gold"));\nlet deps = mock_dependencies_with_balances(20, &[(&rich_addr, &rich_balance)]);\nlet api = MockApi::new(20);\n\n// after\nlet mut deps = mock_dependencies(&[]);\nlet mut deps = mock_dependencies(&coins(123456, "gold"));\nlet deps = mock_dependencies_with_balances(&[(&rich_addr, &rich_balance)]);\nlet api = MockApi::default();\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add ",(0,i.kt)("inlineCode",{parentName:"p"},"MessageInfo")," as separate arg after ",(0,i.kt)("inlineCode",{parentName:"p"},"Env")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"handle"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"migrate"),". Add ",(0,i.kt)("inlineCode",{parentName:"p"},"Env")," arg to ",(0,i.kt)("inlineCode",{parentName:"p"},"query"),".\nUse ",(0,i.kt)("inlineCode",{parentName:"p"},"info.sender")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"env.message.sender"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"info.sent_funds")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"env.message.sent_funds"),". Just changing the function signatures of the 3-4 export\nfunctions should be enough, then the compiler will warn you anywhere you use ",(0,i.kt)("inlineCode",{parentName:"p"},"env.message")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\npub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    env: Env,\n    msg: InitMsg,\n) {\n    deps.storage.set(\n        CONFIG_KEY,\n        &to_vec(&State {\n            verifier: deps.api.canonical_address(&msg.verifier)?,\n            beneficiary: deps.api.canonical_address(&msg.beneficiary)?,\n            funder: deps.api.canonical_address(&env.message.sender)?,\n        })?,\n    );\n}\n\n// after\npub fn init<S: Storage, A: Api, Q: Querier>(\n    deps: &mut Extern<S, A, Q>,\n    _env: Env,\n    info: MessageInfo,\n    msg: InitMsg,\n) {\n    deps.storage.set(\n        CONFIG_KEY,\n        &to_vec(&State {\n            verifier: deps.api.canonical_address(&msg.verifier)?,\n            beneficiary: deps.api.canonical_address(&msg.beneficiary)?,\n            funder: deps.api.canonical_address(&info.sender)?,\n        })?,\n    );\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Test code now has ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_info")," which takes the same args ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_env")," used to. You can just pass ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_env()")," directly\ninto the function calls unless you need to change height/time.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"One more object to pass in for both unit and integration tests. To do this quickly, I just highlight all copies\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"env")," and replace them with ",(0,i.kt)("inlineCode",{parentName:"p"},"info"),"\n(using Ctrl+D in VSCode or Alt+J in IntelliJ). Then I select all ",(0,i.kt)("inlineCode",{parentName:"p"},"deps, info"),"\nsections and replace that with ",(0,i.kt)("inlineCode",{parentName:"p"},"deps, mock_env(), info"),". This fixes up all\n",(0,i.kt)("inlineCode",{parentName:"p"},"init")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"handle")," calls, then just add an extra ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_env()")," to the query calls."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before: unit test\nlet env = mock_env(creator.as_str(), &[]);\nlet res = init(&mut deps, env, msg).unwrap();\n\nlet query_response = query(&deps, QueryMsg::Verifier {}).unwrap();\n\n// after: unit test\nlet info = mock_info(creator.as_str(), &[]);\nlet res = init(&mut deps, mock_env(), info, msg).unwrap();\n\nlet query_response = query(&deps, mock_env(), QueryMsg::Verifier {}).unwrap();\n\n// before: integration test\nlet env = mock_env("creator", &coins(1000, "earth"));\nlet res: InitResponse = init(&mut deps, env, msg).unwrap();\n\nlet query_response = query(&mut deps, QueryMsg::Verifier {}).unwrap();\n\n// after: integration test\nlet info = mock_info("creator", &coins(1000, "earth"));\nlet res: InitResponse = init(&mut deps, mock_env(), info, msg).unwrap();\n\nlet query_response = query(&mut deps, mock_env(), QueryMsg::Verifier {}).unwrap();\n')))),(0,i.kt)("h2",{id:"09---010"},"0.9 -> 0.10"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.10.0"\ncosmwasm-storage = "0.10.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.10.0"\ncosmwasm-vm = "0.10.0"\n# ...\n')))),(0,i.kt)("p",null,"Integration tests:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"Api::human_address")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Api::canonical_address")," now return a pair of result and gas information. Change"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before\nverifier: deps.api.canonical_address(&verifier).unwrap(),\n\n// after\nverifier: deps.api.canonical_address(&verifier).0.unwrap(),\n")),(0,i.kt)("p",{parentName:"li"},"The same applies for all calls of ",(0,i.kt)("inlineCode",{parentName:"p"},"Querier")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Storage"),"."))),(0,i.kt)("p",null,"All Tests:"),(0,i.kt)("p",null,"All usages of ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_env")," will have to remove the first argument (no need of API)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before\nlet env = mock_env( & deps.api, "creator", & coins(1000, "earth"));\n\n// after\nlet env = mock_env("creator", & coins(1000, "earth"));\n')),(0,i.kt)("p",null,"Contracts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"All code that uses ",(0,i.kt)("inlineCode",{parentName:"li"},"message.sender")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"contract.address")," should deal with\n",(0,i.kt)("inlineCode",{parentName:"li"},"HumanAddr")," not ",(0,i.kt)("inlineCode",{parentName:"li"},"CanonicalAddr"),". Many times this means you can remove a conversion step.")),(0,i.kt)("h2",{id:"08---09"},"0.8 -> 0.9"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update CosmWasm dependencies in Cargo.toml (skip the ones you don't use):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'[dependencies]\ncosmwasm-std = "0.9.0"\ncosmwasm-storage = "0.9.0"\n# ...\n\n[dev-dependencies]\ncosmwasm-schema = "0.9.0"\ncosmwasm-vm = "0.9.0"\n# ...\n')))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The C export boilerplate can now be reduced to the following code (see e.g. in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm/blob/0a5b3e8121/contracts/hackatom/src/lib.rs"},"hackatom/src/lib.rs"),"):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'mod contract; // contains init, handle, query\n// maybe additional modules here\n\n#[cfg(target_arch = "wasm32")]\ncosmwasm_std::create_entry_points!(contract);\n')))),(0,i.kt)("p",null,"Contract code and uni tests:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::get_with_prefix"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::set_with_prefix"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::RepLog::commit"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::ReadonlyStorage::get"),",\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::ReadonlyStorage::range"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Storage::set")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Storage::remove")," now return the value directly that was wrapped in a result before."),(0,i.kt)("li",{parentName:"ul"},"Error creator functions are now in type itself, e.g.\n",(0,i.kt)("inlineCode",{parentName:"li"},"StdError::invalid_base64")," instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"invalid_base64"),". The free functions are deprecated and will be removed before\n1.0."),(0,i.kt)("li",{parentName:"ul"},"Remove ",(0,i.kt)("inlineCode",{parentName:"li"},"InitResponse.data")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"init"),". Before 0.9 this was not stored to chain but ignored."),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::transactional")," instead of the removed\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::transactional_deps"),"."),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Never")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Empty"),".")),(0,i.kt)("p",null,"Integration tests:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::ReadonlyStorage")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::Storage"),", which now contains all backend storage methods."),(0,i.kt)("li",{parentName:"ul"},"Storage getters (and iterators) now return a result of\n",(0,i.kt)("inlineCode",{parentName:"li"},"(Option<Vec<u8>>, u64)"),", where the first component is the element and the second one is the gas cost. Thus in a few\nplaces ",(0,i.kt)("inlineCode",{parentName:"li"},".0")," must be added to access the element.")),(0,i.kt)("h2",{id:"072---08"},"0.7.2 -> 0.8"),(0,i.kt)("h3",{id:"update-wasm-code"},"Update wasm code"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," dependencies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Update to ",(0,i.kt)("inlineCode",{parentName:"li"},'schemars = "0.7"')),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm = "0.7"')," with ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm-std = "0.8"')),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm-vm = "0.7"')," with ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm-vm = "0.8"')),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},'cw-storage = "0.2"')," with ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm-storage = "0.8"')),(0,i.kt)("li",{parentName:"ul"},"Remove explicit ",(0,i.kt)("inlineCode",{parentName:"li"},"snafu")," dependency. ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std")," still uses it internally but doesn't expose snafu specifics\nanymore. See more details on errors below.")),(0,i.kt)("p",null,"(Note: until release of ",(0,i.kt)("inlineCode",{parentName:"p"},"0.8"),", you need to use git references for all\n",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_*")," packages)"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},'"cosmwasm/backtraces"')," with ",(0,i.kt)("inlineCode",{parentName:"li"},'"cosmwasm-std/backtraces"'))),(0,i.kt)("p",null,"Imports:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace all ",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm::X::Y")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::Y"),", except for mock"),(0,i.kt)("li",{parentName:"ul"},"Replace all ",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm::mock::Y")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::testing::Y"),". This should only be used in test code."),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"cw_storage:X")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_storage::X")),(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::Response")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::HandleResponse")," and\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_std::InitResponse")," (different type for each call)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"src/lib.rs"),":"),(0,i.kt)("p",null,"This has been re-written, but is generic boilerplate and should be (almost) the same in all contracts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"copy the new version from\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/CosmWasm/cosmwasm/blob/master/contracts/queue/src/lib.rs"},(0,i.kt)("inlineCode",{parentName:"a"},"contracts/queue"))),(0,i.kt)("li",{parentName:"ul"},"Add ",(0,i.kt)("inlineCode",{parentName:"li"},"pub mod XYZ")," directives for any modules you use besides ",(0,i.kt)("inlineCode",{parentName:"li"},"contract"))),(0,i.kt)("p",null,"Contract Code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add query to extern:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Before: ",(0,i.kt)("inlineCode",{parentName:"li"},"my_func<S: Storage, A: Api>(deps: &Extern<S, A>, ...")),(0,i.kt)("li",{parentName:"ul"},"After: ",(0,i.kt)("inlineCode",{parentName:"li"},"my_func<S: Storage, A: Api, Q: Querier>(deps: &Extern<S, A, Q>, ...")),(0,i.kt)("li",{parentName:"ul"},"Remember to add ",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::Querier;")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"query")," now returns ",(0,i.kt)("inlineCode",{parentName:"p"},"StdResult<Binary>")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Result<Vec<u8>>")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can also replace ",(0,i.kt)("inlineCode",{parentName:"li"},"to_vec(...)")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"to_binary(...)")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"No ",(0,i.kt)("inlineCode",{parentName:"p"},".context(...)")," is required after ",(0,i.kt)("inlineCode",{parentName:"p"},"from_slice")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"to_vec"),", they return proper ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::Error")," variants on\nerrors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"env.message.signer")," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"env.message.sender"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you used ",(0,i.kt)("inlineCode",{parentName:"p"},"env.contract.balance"),", you must now use the querier. The following code block should work:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// before (in env)\nlet foo = env.contract.balance;\n\n// after (query my balance)\nlet contract_addr = deps.api.human_address(&env.contract.address)?;\nlet balance = deps.querier.query_all_balances(&contract_addr)?;\nlet foo = balance.amount;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosMsg")," enums used:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Send{}")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Bank(BankMsg::Send{})")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Opaque{ data }")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Native{ msg }")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Contract")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Wasm(WasmMsg::Execute{})")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Complete overhaul of ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm::Error")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::StdError"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Auto generated snafu error constructor structs like ",(0,i.kt)("inlineCode",{parentName:"li"},"NotFound"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"ParseErr"),"/\u2026 have been privatized in favour of error\ngeneration helpers like\n",(0,i.kt)("inlineCode",{parentName:"li"},"not_found"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"parse_err"),"/\u2026"),(0,i.kt)("li",{parentName:"ul"},"All error generator functions now return errors instead of results, such that e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"return unauthorized();"),"\nbecomes ",(0,i.kt)("inlineCode",{parentName:"li"},"return Err(unauthorized());")),(0,i.kt)("li",{parentName:"ul"},"Error cases don't contain ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," fields anymore. Instead source errors are converted to standard types\nlike ",(0,i.kt)("inlineCode",{parentName:"li"},"String"),". For this reason, both\n",(0,i.kt)("inlineCode",{parentName:"li"},"snafu::ResultExt")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"snafu::OptionExt")," cannot be used anymore. An error wrapper now looks\nlike ",(0,i.kt)("inlineCode",{parentName:"li"},".map_err(invalid_base64)")," and an ",(0,i.kt)("inlineCode",{parentName:"li"},"Option::None")," to error mapping looks\nlike ",(0,i.kt)("inlineCode",{parentName:"li"},'.ok_or_else(|| not_found("State"))'),"."),(0,i.kt)("li",{parentName:"ul"},"Backtraces became optional. Use ",(0,i.kt)("inlineCode",{parentName:"li"},"RUST_BACKTRACE=1")," to enable them for unit tests."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Utf8Err"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"Utf8StringErr")," merged into ",(0,i.kt)("inlineCode",{parentName:"li"},"StdError::InvalidUtf8")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Base64Err")," renamed into ",(0,i.kt)("inlineCode",{parentName:"li"},"StdError::InvalidBase64")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ContractErr"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"DynContractErr")," merged into ",(0,i.kt)("inlineCode",{parentName:"li"},"StdError::GenericErr"),", thus both\n",(0,i.kt)("inlineCode",{parentName:"li"},"contract_err")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"dyn_contract_err")," must be replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"generic_err"),"."),(0,i.kt)("li",{parentName:"ul"},"The unused ",(0,i.kt)("inlineCode",{parentName:"li"},"ValidationErr")," was removed")))),(0,i.kt)("p",null,"At this point ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo wasm")," should pass."),(0,i.kt)("h3",{id:"update-test-code"},"Update test code"),(0,i.kt)("p",null,"Both:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update all imports from ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm::mock::*")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm_std::testing::*"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"from_binary")," not ",(0,i.kt)("inlineCode",{parentName:"p"},"from_slice")," on all query responses (update imports)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from_slice(res.as_slice())")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"from_binary(&res)")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Replace ",(0,i.kt)("inlineCode",{parentName:"p"},'coin("123", "FOO")')," with ",(0,i.kt)("inlineCode",{parentName:"p"},'coins(123, "FOO")'),". We renamed it to coins to be more explicit that it\nreturns ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec<Coin>"),", and now accept a ",(0,i.kt)("inlineCode",{parentName:"p"},"u128")," as the first argument for better type-safety. ",(0,i.kt)("inlineCode",{parentName:"p"},"coin")," is now an alias to\n",(0,i.kt)("inlineCode",{parentName:"p"},"Coin::new")," and returns one ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Remove the 4th argument (contract balance) from all calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_env"),", this is no longer stored in the environment.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"dependencies")," was renamed to ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_dependencies"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_dependencies")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"mock_instance")," take a 2nd argument to set the contract balance (visible for the querier). If you need to set more\nbalances, use ",(0,i.kt)("inlineCode",{parentName:"p"},"mock_XX_with_balances"),". The follow code block explains:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// before: balance as last arg in mock_env\nlet mut deps = dependencies(20);\nlet env = mock_env(&deps.api, "creator", &coins(15, "earth"), &coins(1015, "earth"));\n\n// after: balance as last arg in mock_dependencies\nlet mut deps = mock_dependencies(20, &coins(1015, "earth"));\nlet env = mock_env(&deps.api, "creator", &coins(15, "earth"));\n')))),(0,i.kt)("p",null,"Unit Tests:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace ",(0,i.kt)("inlineCode",{parentName:"li"},"dependencies")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"mock_dependencies"))),(0,i.kt)("p",null,"Integration Tests:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We no longer check errors as strings but have rich types:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Before:\n",(0,i.kt)("inlineCode",{parentName:"li"},'match err { ContractResult::Err(msg) => assert_eq!(msg, "Unauthorized"), ... }')),(0,i.kt)("li",{parentName:"ul"},"After: ",(0,i.kt)("inlineCode",{parentName:"li"},"match err { Err(StdError::Unauthorized{ .. }) => {}, ... }")))),(0,i.kt)("li",{parentName:"ul"},"Remove all imports / use of ",(0,i.kt)("inlineCode",{parentName:"li"},"ContractResult")),(0,i.kt)("li",{parentName:"ul"},"You must specify ",(0,i.kt)("inlineCode",{parentName:"li"},"CosmosMsg::Native")," type when calling\n",(0,i.kt)("inlineCode",{parentName:"li"},"cosmwasm_vm::testing::{handle, init}"),". You will want to\n",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::{HandleResult, InitResult}")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"use cosmwasm_std::{HandleResponse, InitResponse}"),". If you don't use custom native types, simply update calls as\nfollows:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let res = init(...)")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"let res: InitResult = init(...)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let res = init(...).unwrap()")," =>\n",(0,i.kt)("inlineCode",{parentName:"li"},"let res: InitResponse = init(...).unwrap()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let res = handle(...)")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"let res: HandleResult = handle(...)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let res = handle(...).unwrap()")," =>\n",(0,i.kt)("inlineCode",{parentName:"li"},"let res: HandleResponse = handle(...).unwrap()"))))),(0,i.kt)("h3",{id:"update-schema-code"},"Update schema code"),(0,i.kt)("p",null,"All helper functions have been moved into a new ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmwasm-schema")," package."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Add ",(0,i.kt)("inlineCode",{parentName:"li"},'cosmwasm-schema = "0.8"')," to ",(0,i.kt)("inlineCode",{parentName:"li"},"[dev-dependencies]")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"Cargo.toml")),(0,i.kt)("li",{parentName:"ul"},"Remove ",(0,i.kt)("inlineCode",{parentName:"li"},"serde_json")," ",(0,i.kt)("inlineCode",{parentName:"li"},"[dev-dependency]")," if there, as cosmwasm-schema will handle JSON output internally."),(0,i.kt)("li",{parentName:"ul"},"Update ",(0,i.kt)("inlineCode",{parentName:"li"},"examples/schema.rs")," to look\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/CosmWasm/cosmwasm/blob/master/contracts/queue/examples/schema.rs"},"more like queue"),", but replacing\nall the imports and type names with those you currently have."),(0,i.kt)("li",{parentName:"ul"},"Regenerate schemas with ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo schema"))),(0,i.kt)("h3",{id:"polishing"},"Polishing"),(0,i.kt)("p",null,"After so many changes, remember to let the linters do their jobs."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cargo fmt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cargo clippy"))))}c.isMDXComponent=!0}}]);