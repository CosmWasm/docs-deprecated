"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7537],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return m}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(r),m=i,k=d["".concat(l,".").concat(m)]||d[m]||p[m]||a;return r?n.createElement(k,o(o({ref:t},u),{},{components:r})):n.createElement(k,o({ref:t},u))}));function m(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},2589:function(e,t,r){r.r(t),r.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return c}});var n=r(3117),i=(r(7294),r(3905));const a={id:"cw20-merkle-airdrop",sidebar_position:4,title:"CW20 Merkle Airdrop"},o="CW20 Merkle Airdrop",s={unversionedId:"cw20-merkle-airdrop",id:"cw20-merkle-airdrop",title:"CW20 Merkle Airdrop",description:"Source code is at cw20-merkle-airdrop.",source:"@site/cw-tokens/cw20-merkle-airdrop.md",sourceDirName:".",slug:"/cw20-merkle-airdrop",permalink:"/cw-tokens/cw20-merkle-airdrop",draft:!1,editUrl:"https://github.com/InterWasm/docs/edit/main/cw-tokens/cw20-merkle-airdrop.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"cw20-merkle-airdrop",sidebar_position:4,title:"CW20 Merkle Airdrop"},sidebar:"cwPlus",previous:{title:"CW20 Escrow",permalink:"/cw-tokens/cw20-escrow"},next:{title:"CW20 Staking",permalink:"/cw-tokens/cw20-staking"}},l={},c=[{value:"Procedure",id:"procedure",level:2},{value:"Spec",id:"spec",level:2},{value:"Messages",id:"messages",level:3},{value:"InstantiateMsg",id:"instantiatemsg",level:4},{value:"ExecuteMsg",id:"executemsg",level:4},{value:"QueryMsg",id:"querymsg",level:4}],u={toc:c};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cw20-merkle-airdrop"},"CW20 Merkle Airdrop"),(0,i.kt)("p",null,"Source code is at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-tokens/tree/main/contracts/cw20-merkle-airdrop"},"cw20-merkle-airdrop"),"."),(0,i.kt)("p",null,"This is a merkle airdrop smart contract that works with cw20 token specification Mass airdrop distributions made cheap\nand efficient."),(0,i.kt)("p",null,"Explanation of merkle\nairdrop: ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/smartz-blog/merkle-airdrop-the-basics-9a0857fcc930"},"Medium Merkle Airdrop: the Basics")),(0,i.kt)("p",null,"Traditional and non-efficient airdrops:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Distributor creates a list of airdrop"),(0,i.kt)("li",{parentName:"ul"},"Sends bank send messages to send tokens to recipients")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Or")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stores list of recipients on smart contract data"),(0,i.kt)("li",{parentName:"ul"},"Recipient claims the airdrop")),(0,i.kt)("p",null,"These two solutions are very ineffective when recipient list is big. First, costly because bank send cost for the\ndistributor will be costly. Second, whole airdrop list stored in the state, again costly."),(0,i.kt)("p",null,"Merkle Airdrop is very efficient even when recipient number is massive."),(0,i.kt)("p",null,"This contract works with multiple airdrop rounds, meaning you can execute several airdrops using same instance."),(0,i.kt)("p",null,"Uses ",(0,i.kt)("strong",{parentName:"p"},"SHA256")," for merkle root tree construction."),(0,i.kt)("h2",{id:"procedure"},"Procedure"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Distributor of contract prepares a list of addresses with many entries and publishes this list in public static .js\nfile in JSON format"),(0,i.kt)("li",{parentName:"ul"},"Distributor reads this list, builds the merkle tree structure and writes down the Merkle root of it."),(0,i.kt)("li",{parentName:"ul"},"Distributor creates contract and places calculated Merkle root into it."),(0,i.kt)("li",{parentName:"ul"},"Distributor says to users, that they can claim their tokens, if they owe any of addresses, presented in list,\npublished on distributor's site."),(0,i.kt)("li",{parentName:"ul"},"User wants to claim his N tokens, he also builds Merkle tree from public list and prepares Merkle proof, consisting\nfrom log2N hashes, describing the way to reach Merkle root"),(0,i.kt)("li",{parentName:"ul"},"User sends transaction with Merkle proof to contract"),(0,i.kt)("li",{parentName:"ul"},"Contract checks Merkle proof, and, if proof is correct, then sender's address is in list of allowed addresses, and\ncontract does some action for this use."),(0,i.kt)("li",{parentName:"ul"},"Distributor sends token to the contract, and registers new merkle root for the next distribution round.")),(0,i.kt)("h2",{id:"spec"},"Spec"),(0,i.kt)("h3",{id:"messages"},"Messages"),(0,i.kt)("h4",{id:"instantiatemsg"},"InstantiateMsg"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"InstantiateMsg")," instantiates contract with owner and cw20 token address. Airdrop ",(0,i.kt)("inlineCode",{parentName:"p"},"stage")," is set to 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct InstantiateMsg {\n  pub owner: String,\n  pub cw20_token_address: String,\n}\n")),(0,i.kt)("h4",{id:"executemsg"},"ExecuteMsg"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum ExecuteMsg {\n  UpdateConfig {\n    owner: Option<String>,\n  },\n  RegisterMerkleRoot {\n    merkle_root: String,\n  },\n  Claim {\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n  },\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UpdateConfig{owner}")," updates configuration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RegisterMerkleRoot {merkle_root}")," registers merkle tree root for further claim verification. Airdrop ",(0,i.kt)("inlineCode",{parentName:"li"},"Stage"),"\nincreased by 1."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Claim{stage, amount, proof}")," recipient executes for claiming airdrop with ",(0,i.kt)("inlineCode",{parentName:"li"},"stage"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"amount")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"proof")," data built\nusing full list.")),(0,i.kt)("h4",{id:"querymsg"},"QueryMsg"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum QueryMsg {\n    Config {},\n    MerkleRoot { stage: u8 },\n    LatestStage {},\n    IsClaimed { stage: u8, address: String },\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{ config: {} }")," returns configuration, ",(0,i.kt)("inlineCode",{parentName:"li"},'{"cw20_token_address": ..., "owner": ...}'),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'{ merkle_root: { stage: "1" }')," returns merkle root of given stage, ",(0,i.kt)("inlineCode",{parentName:"li"},'{"merkle_root": ... , "stage": ...}')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{ latest_stage: {}}")," returns current airdrop stage, ",(0,i.kt)("inlineCode",{parentName:"li"},'{"latest_stage": ...}')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'{ is_claimed: {stage: "stage", address: "wasm1..."}')," returns if address claimed airdrop, ",(0,i.kt)("inlineCode",{parentName:"li"},'{"is_claimed": "true"}'))))}p.isMDXComponent=!0}}]);